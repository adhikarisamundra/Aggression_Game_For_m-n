import random
import time

class AggressionGame:
    def __init__(self):
        self.rows = 0
        self.cols = 0
        self.total_troops = 0
        self.grid = {}  # Dictionary to store grid state: (r, c) -> {'player': p, 'count': n}
        self.p1_troops_remaining = 0
        self.p2_troops_remaining = 0
        self.current_turn = 1  # 1 for Player 1, 2 for Player 2
        self.ai_opponent = None # None, "Weak", "Strategic", "Smart"
        self.player_names = {1: "Player 1", 2: "Player 2"}

    def setup_game(self):
        """Initializes game parameters with user input and safety caps."""
        print("--- Game Setup ---")
        
        # 1. Grid Dimensions (Limited to 8x8 for algorithmic complexity reasons)
        while True:
            try:
                r = int(input("Enter number of rows (m) [2-8]: "))
                c = int(input("Enter number of columns (n) [2-8]: "))
                if 2 <= r <= 8 and 2 <= c <= 8:
                    self.rows, self.cols = r, c
                    break
                print("Dimensions must be between 2 and 8.")
            except ValueError:
                print("Invalid input. Please enter integers.")

        # 2. Troop Count 
        # Default is m*n, but user can change. 
        # We cap this to prevent integer overflow or excessively long games.
        default_troops = self.rows * self.cols
        print(f"Standard troop count is {default_troops} (rows * cols).")
        while True:
            try:
                choice = input(f"Use standard count? (y/n): ").lower()
                if choice == 'y':
                    self.total_troops = default_troops
                    break
                elif choice == 'n':
                    # Cap troops at 3x grid size
                    max_troops = self.rows * self.cols * 3
                    t = int(input(f"Enter total troops per player [1-{max_troops}]: "))
                    if 1 <= t <= max_troops:
                        self.total_troops = t
                        break
                    print(f"Please keep troops between 1 and {max_troops}.")
            except ValueError:
                print("Invalid input.")

        self.p1_troops_remaining = self.total_troops
        self.p2_troops_remaining = self.total_troops

        # 3. Game Mode Selection
        print("\n--- Opponent Selection ---")
        print("1. Human vs Human")
        print("2. Human vs AI")
        while True:
            mode = input("Choose mode (1 or 2): ")
            if mode == '1':
                self.ai_opponent = None
                break
            elif mode == '2':
                self.choose_ai_difficulty()
                self.player_names[2] = f"AI ({self.ai_opponent})"
                break

        # Initialize empty grid
        for r in range(self.rows):
            for c in range(self.cols):
                self.grid[(r, c)] = None # None means empty/unclaimed

        # Start the game loop
        self.play_placement_phase()

    def choose_ai_difficulty(self):
        """Allows user to select AI based on description."""
        print("\nSelect AI Difficulty:")
        print("1. Weak AI (Random):") 
        print("   - Makes moves completely randomly.")
        print("   - No strategy; good for learning the mechanics.")
        
        print("2. Strategic AI (Clustering):")
        print("   - Tries to group troops together to build strongholds.")
        print("   - Prioritizes attacking the largest enemy stacks.")
        
        print("3. Smart AI (Threat Assessment):")
        print("   - Analyzes which of its own units are threatened.")
        print("   - Attacks enemies that pose the biggest danger to its territory.")
        
        while True:
            choice = input("Enter choice (1-3): ")
            if choice == '1':
                self.ai_opponent = "Weak"
                break
            elif choice == '2':
                self.ai_opponent = "Strategic"
                break
            elif choice == '3':
                self.ai_opponent = "Smart"
                break

    def print_grid(self):
        """Visualizes the current board state."""
        print(f"\n--- Board State (Rows: {self.rows}, Cols: {self.cols}) ---")
        # Column headers
        print("   ", end="")
        for c in range(self.cols):
            print(f" {c}  ", end="")
        print()
        
        for r in range(self.rows):
            print(f"{r} |", end="")
            for c in range(self.cols):
                cell = self.grid.get((r, c))
                if cell is None:
                    print(" .  ", end="")
                else:
                    # Format: P1:5 or P2:10
                    p_label = f"P{cell['player']}"
                    count = cell['count']
                    # Simple color coding using ANSI escape codes for terminal
                    color = "\033[94m" if cell['player'] == 1 else "\033[91m"
                    reset = "\033[0m"
                    print(f"{color}{p_label}:{count:<2}{reset}", end="") 
            print("|")

    # --- PLACEMENT PHASE LOGIC ---

    def play_placement_phase(self):
        """Manages the loop of placing troops until both run out."""
        print("\n--- Phase 1: Placement ---")
        print(f"Rules: Place troops (1 to remaining). You stop when out of troops.")
        
        # Randomly decide who starts placement
        if random.choice([True, False]):
            self.current_turn = 1
        else:
            self.current_turn = 2
        print(f"{self.player_names[self.current_turn]} starts placement.")

        while self.p1_troops_remaining > 0 or self.p2_troops_remaining > 0:
            self.print_grid()
            current_troops = self.p1_troops_remaining if self.current_turn == 1 else self.p2_troops_remaining
            
            # Skip turn if out of troops
            if current_troops <= 0:
                print(f"{self.player_names[self.current_turn]} is out of troops. Skipping.")
                self.switch_turn()
                continue

            print(f"\n{self.player_names[self.current_turn]}'s Turn.")
            print(f"Troops remaining: {current_troops}")

            if self.is_ai_turn():
                move = self.get_ai_placement_move()
                print(f"AI decides to place {move['amount']} at ({move['r']}, {move['c']}).")
                self.execute_placement(move['r'], move['c'], move['amount'])
            else:
                self.get_human_placement_move(current_troops)
            
            self.switch_turn()

        print("\nAll troops placed. Transitioning to Attack Phase...")
        self.play_attack_phase()

    def get_human_placement_move(self, max_troops):
        while True:
            try:
                in_str = input("Enter placement (row col amount): ")
                parts = list(map(int, in_str.split()))
                if len(parts) != 3:
                    print("Format: row col amount")
                    continue
                r, c, amount = parts
                
                # Validation
                if not (0 <= r < self.rows and 0 <= c < self.cols):
                    print("Coordinates out of bounds.")
                    continue
                if amount < 1 or amount > max_troops:
                    print(f"Invalid amount. You have {max_troops} left.")
                    continue
                
                cell = self.grid.get((r, c))
                # Can only place on empty spots or own territory
                if cell is not None and cell['player'] != self.current_turn:
                    print("Cannot place on opponent's territory!")
                    continue
                
                self.execute_placement(r, c, amount)
                break
            except ValueError:
                print("Invalid input.")

    def execute_placement(self, r, c, amount):
        cell = self.grid.get((r, c))
        if cell is None:
            self.grid[(r, c)] = {'player': self.current_turn, 'count': amount}
        else:
            self.grid[(r, c)]['count'] += amount
            
        if self.current_turn == 1:
            self.p1_troops_remaining -= amount
        else:
            self.p2_troops_remaining -= amount

    # --- ATTACK PHASE LOGIC ---

    def play_attack_phase(self):
        """Manages the attack loop."""
        print("\n--- Phase 2: Attack ---")
        print("Rules: Attack a target. If (Sum of your surrounding troops) > (Target troops), target is neutralized.")
        
        # The person who placed first starts the attack phase (rule interpretation)
        # For simplicity in code, we just reset to P1, but you can randomize.
        self.current_turn = 1 
        consecutive_passes = 0

        while True:
            self.print_grid()
            
            print(f"\n{self.player_names[self.current_turn]}'s Turn.")
            print("Enter target coordinates to attack, or 'p' to pass.")
            
            move_made = False
            
            if self.is_ai_turn():
                time.sleep(1) # Small delay for realism
                target = self.get_ai_attack_move()
                if target is None:
                    print("AI chooses to Pass.")
                    consecutive_passes += 1
                else:
                    print(f"AI attacks ({target[0]}, {target[1]})!")
                    self.execute_attack(target[0], target[1])
                    move_made = True
                    consecutive_passes = 0
            else:
                user_in = input("Target (row col) or 'p': ").lower()
                if user_in == 'p':
                    consecutive_passes += 1
                else:
                    try:
                        r, c = map(int, user_in.split())
                        if self.validate_attack(r, c):
                            self.execute_attack(r, c)
                            move_made = True
                            consecutive_passes = 0
                        else:
                            continue # Ask again
                    except ValueError:
                        print("Invalid input.")
                        continue

            # Win Condition Check: If 2 passes in a row, game ends.
            if consecutive_passes >= 2:
                print("\nBoth players passed. Game Over.")
                break
                
            self.switch_turn()
            
        self.determine_winner()

    def validate_attack(self, r, c):
        if not (0 <= r < self.rows and 0 <= c < self.cols):
            print("Out of bounds.")
            return False
        
        target_cell = self.grid.get((r, c))
        if target_cell is None:
            print("Cannot attack empty space.")
            return False
        if target_cell['player'] == self.current_turn:
            print("Cannot attack your own territory.")
            return False
            
        # Calculate attack power
        power = self.calculate_attack_power(r, c, self.current_turn)
        print(f"Attack Power (Sum of neighbors): {power} vs Target Defense: {target_cell['count']}")
        
        if power > target_cell['count']:
            return True
        else:
            print("Attack failed! Insufficient surrounding power.")
            return False

    def calculate_attack_power(self, target_r, target_c, attacker_id):
        power = 0
        # Check all 8 surrounding neighbors (Kings move)
        for dr in [-1, 0, 1]:
            for dc in [-1, 0, 1]:
                if dr == 0 and dc == 0: continue
                nr, nc = target_r + dr, target_c + dc
                if (nr, nc) in self.grid and self.grid[(nr, nc)] is not None:
                    if self.grid[(nr, nc)]['player'] == attacker_id:
                        power += self.grid[(nr, nc)]['count']
        return power

    def execute_attack(self, r, c):
        # Neutralized territory becomes empty (None)
        print(f"Attack successful! Territory at ({r},{c}) neutralized (removed).")
        self.grid[(r, c)] = None

    def determine_winner(self):
        p1_area = 0
        p2_area = 0
        for cell in self.grid.values():
            if cell is not None:
                if cell['player'] == 1:
                    p1_area += 1
                else:
                    p2_area += 1
        
        print("\n--- Final Score ---")
        print(f"Player 1 Area Controlled: {p1_area}")
        print(f"Player 2 Area Controlled: {p2_area}")
        
        if p1_area > p2_area:
            print("Player 1 Wins!")
        elif p2_area > p1_area:
            print("Player 2 Wins!")
        else:
            print("It's a Tie!")

    # --- AI LOGIC IMPLEMENTATION ---

    def is_ai_turn(self):
        return self.current_turn == 2 and self.ai_opponent is not None

    def get_ai_placement_move(self):
        remaining = self.p2_troops_remaining
        
        # 1. WEAK AI: Pure Random
        if self.ai_opponent == "Weak":
            # Picks random coord
            r = random.randint(0, self.rows - 1)
            c = random.randint(0, self.cols - 1)
            # Random amount
            amt = random.randint(1, min(remaining, 5))
            
            # Ensure valid spot (empty or own)
            valid = False
            attempts = 0
            while not valid and attempts < 100:
                cell = self.grid.get((r,c))
                if cell is None or cell['player'] == 2:
                    valid = True
                else:
                    r = random.randint(0, self.rows - 1)
                    c = random.randint(0, self.cols - 1)
                attempts += 1
            
            if not valid: # Fallback if grid is full of enemy (unlikely in setup)
                 amt = remaining 
            
            return {'r': r, 'c': c, 'amount': amt}

        # 2. STRATEGIC & SMART AI (Placement Logic)
        # Both prefer clustering, but Smart is more aggressive.
        else:
            best_score = -999
            best_move = (0, 0)
            
            for r in range(self.rows):
                for c in range(self.cols):
                    cell = self.grid.get((r, c))
                    if cell is not None and cell['player'] == 1: continue 
                    
                    score = 0
                    # Check neighbors for friends
                    friendly_power = self.calculate_attack_power(r, c, 2)
                    score += friendly_power
                    
                    if cell is None: score += 2 # Slight preference for claiming new ground
                    
                    # Random noise to vary games
                    score += random.random()
                    
                    if score > best_score:
                        best_score = score
                        best_move = (r, c)
            
            amt = min(remaining, random.randint(3, 6))
            return {'r': best_move[0], 'c': best_move[1], 'amount': amt}

    def get_ai_attack_move(self):
        possible_attacks = []
        
        # Identify all valid attacks against Player 1
        for r in range(self.rows):
            for c in range(self.cols):
                cell = self.grid.get((r, c))
                # Target must be enemy
                if cell is not None and cell['player'] == 1:
                    power = self.calculate_attack_power(r, c, 2)
                    if power > cell['count']:
                        possible_attacks.append( {'r':r, 'c':c, 'target_val': cell['count']} )

        if not possible_attacks:
            return None

        # 1. WEAK AI: Random valid attack
        if self.ai_opponent == "Weak":
            choice = random.choice(possible_attacks)
            return (choice['r'], choice['c'])

        # 2. STRATEGIC AI: Greedy approach
        # Targets the largest enemy stack it can defeat to remove max troops from board.
        if self.ai_opponent == "Strategic":
            best_attack = max(possible_attacks, key=lambda x: x['target_val'])
            return (best_attack['r'], best_attack['c'])

        # 3. SMART AI: Threat Reduction
        # Targets the enemy that is exerting the most pressure on AI's own troops.
        if self.ai_opponent == "Smart":
            best_attack = None
            max_threat_removed = -1
            
            for att in possible_attacks:
                r, c = att['r'], att['c']
                # Calculate how much power this specific enemy unit has against ME
                # (i.e., how many of my units are neighbors to this enemy?)
                threat_level = self.calculate_attack_power(r, c, 1) # reusing function: this calculates P1 neighbors around P1 unit
                # Actually, we need to know P1's attack power against P2.
                # Let's count P2 neighbors around this P1 target.
                
                # If I remove this P1 unit, I save my neighbors from its influence.
                threat_score = 0
                for dr in [-1, 0, 1]:
                    for dc in [-1, 0, 1]:
                         if dr==0 and dc==0: continue
                         nr, nc = r+dr, c+dc
                         if (nr, nc) in self.grid and self.grid[(nr, nc)] and self.grid[(nr, nc)]['player'] == 2:
                             threat_score += 1
                
                # Combine value of target + threat removal
                total_val = att['target_val'] + (threat_score * 2)
                
                if total_val > max_threat_removed:
                    max_threat_removed = total_val
                    best_attack = att
            
            return (best_attack['r'], best_attack['c'])

    def switch_turn(self):
        self.current_turn = 1 if self.current_turn == 2 else 2

if __name__ == "__main__":
    game = AggressionGame()
    game.setup_game()
