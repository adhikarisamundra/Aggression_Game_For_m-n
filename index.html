<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>AGGRESSION: OMEGA PROTOCOL</title>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Share+Tech+Mono&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-deep: #020408;
            --panel-bg: rgba(10, 16, 26, 0.95);
            --p1-hex: #00f3ff;
            --p2-hex: #ff003c;
            --accent-hex: #00ff9d;
            --text-main: #e2e8f0;
            --border-color: rgba(0, 255, 157, 0.2);
        }

        * { box-sizing: border-box; user-select: none; -webkit-tap-highlight-color: transparent; }

        body {
            font-family: 'Share Tech Mono', monospace;
            background-color: var(--bg-deep);
            color: var(--text-main);
            margin: 0;
            height: 100vh;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            background-image: 
                radial-gradient(circle at 50% 50%, #0a1525 0%, #000 100%);
        }

        /* --- PARTICLES CANVAS --- */
        #vfx-canvas {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; z-index: 50;
        }

        /* --- UI FRAMEWORK --- */
        .glass-panel {
            background: var(--panel-bg);
            border: 1px solid var(--border-color);
            box-shadow: 0 0 20px rgba(0, 255, 157, 0.05), inset 0 0 50px rgba(0,0,0,0.8);
            backdrop-filter: blur(5px);
            border-radius: 4px;
            position: relative;
        }

        .btn {
            background: rgba(0, 255, 157, 0.1);
            color: var(--accent-hex);
            border: 1px solid var(--accent-hex);
            padding: 12px 24px;
            font-family: 'Orbitron', sans-serif;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 2px;
            cursor: pointer;
            transition: all 0.2s;
            clip-path: polygon(15px 0, 100% 0, 100% calc(100% - 15px), calc(100% - 15px) 100%, 0 100%, 0 15px);
        }
        .btn:hover { background: var(--accent-hex); color: #000; box-shadow: 0 0 15px var(--accent-hex); }
        .btn:active { transform: scale(0.98); }
        .btn-danger { color: var(--p2-hex); border-color: var(--p2-hex); background: rgba(255, 0, 60, 0.1); }
        .btn-danger:hover { background: var(--p2-hex); box-shadow: 0 0 15px var(--p2-hex); }

        /* --- SETUP SCREEN --- */
        #setup-screen {
            position: absolute; z-index: 100;
            display: flex; flex-direction: column; align-items: center; gap: 20px;
            padding: 40px; width: 90%; max-width: 600px;
        }
        
        h1 {
            font-family: 'Orbitron'; font-size: 4rem; margin: 0;
            background: linear-gradient(180deg, #fff, #444);
            -webkit-background-clip: text; -webkit-text-fill-color: transparent;
            filter: drop-shadow(0 0 10px rgba(0,255,157,0.3));
            letter-spacing: 5px; text-align: center;
        }

        .config-row { display: flex; gap: 10px; width: 100%; justify-content: center; }
        input, select {
            background: #000; border: 1px solid #333; color: var(--accent-hex);
            padding: 10px; font-family: 'Share Tech Mono'; font-size: 1.2rem;
            text-align: center; width: 100%; outline: none;
        }
        input:focus { border-color: var(--accent-hex); }
        label { color: #666; font-size: 0.8rem; text-transform: uppercase; display: block; margin-bottom: 5px; text-align: left; }

        /* --- GAME LAYOUT --- */
        #game-ui {
            display: none; /* Hidden on load */
            grid-template-columns: 250px 1fr 250px;
            width: 100%; height: 100%; padding: 20px; gap: 20px;
            position: relative; z-index: 10;
        }

        .sidebar { display: flex; flex-direction: column; justify-content: center; padding: 20px; gap: 20px; transition: 0.3s; }
        .sidebar.active { border-color: currentColor; box-shadow: 0 0 30px currentColor; }
        .p1-color { color: var(--p1-hex); }
        .p2-color { color: var(--p2-hex); }
        
        .stat-display { text-align: center; }
        .stat-val { font-family: 'Orbitron'; font-size: 3rem; font-weight: 900; line-height: 1; text-shadow: 0 0 10px currentColor; }
        .stat-label { font-size: 0.8rem; opacity: 0.7; letter-spacing: 2px; margin-top: 5px; }

        #center-view { display: flex; flex-direction: column; align-items: center; justify-content: center; position: relative; }
        
        #phase-bar {
            background: rgba(0,0,0,0.5); padding: 8px 30px; border: 1px solid #333;
            font-family: 'Orbitron'; letter-spacing: 4px; color: #fff; margin-bottom: 20px;
            clip-path: polygon(10px 0, 100% 0, 100% calc(100% - 10px), calc(100% - 10px) 100%, 0 100%, 0 10px);
        }

        #board-wrapper {
            position: relative; padding: 15px; border: 1px solid #333;
            background: rgba(0,0,0,0.8);
        }

        #grid { display: grid; gap: 4px; }
        
        .cell {
            width: 55px; height: 55px; background: #0f1219;
            display: flex; justify-content: center; align-items: center;
            font-family: 'Orbitron'; font-weight: bold; font-size: 1.4rem;
            cursor: pointer; position: relative; overflow: hidden;
            transition: transform 0.1s, background 0.2s;
        }
        .cell:before {
            content: ''; position: absolute; width: 2px; height: 2px;
            background: #333; top: 2px; right: 2px;
        }
        .cell:hover { background: #1a2233; z-index: 2; transform: scale(1.1); box-shadow: 0 0 15px #000; border: 1px solid #555; }
        
        .cell.p1 { border: 2px solid var(--p1-hex); color: var(--p1-hex); background: rgba(0, 243, 255, 0.1); box-shadow: inset 0 0 15px rgba(0, 243, 255, 0.2); }
        .cell.p2 { border: 2px solid var(--p2-hex); color: var(--p2-hex); background: rgba(255, 0, 60, 0.1); box-shadow: inset 0 0 15px rgba(255, 0, 60, 0.2); }
        
        /* Attack Animation */
        .cell.valid-target { animation: glitchBorder 1s infinite; cursor: crosshair; }
        @keyframes glitchBorder { 
            0% { box-shadow: 0 0 0 var(--p2-hex); } 
            50% { box-shadow: 0 0 20px var(--p2-hex), inset 0 0 10px var(--p2-hex); } 
            100% { box-shadow: 0 0 0 var(--p2-hex); } 
        }

        #controls { margin-top: 20px; display: flex; gap: 15px; align-items: center; }

        /* --- DATA TERMINAL (MODAL) --- */
        .modal-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.9); z-index: 200; display: none;
            justify-content: center; align-items: center; backdrop-filter: blur(10px);
        }
        .terminal {
            width: 800px; max-width: 95%; height: 80vh;
            background: #050505; border: 1px solid var(--accent-hex);
            display: flex; flex-direction: column; font-family: 'Share Tech Mono';
            box-shadow: 0 0 50px rgba(0, 255, 157, 0.1);
        }
        .terminal-header {
            background: var(--accent-hex); color: #000; padding: 10px;
            font-weight: bold; display: flex; justify-content: space-between;
        }
        .terminal-body { flex: 1; padding: 20px; overflow-y: auto; color: #aaa; }
        
        .log-table { width: 100%; border-collapse: collapse; margin-top: 10px; }
        .log-table th { text-align: left; border-bottom: 1px solid #333; color: var(--accent-hex); padding: 5px; }
        .log-table td { border-bottom: 1px solid #222; padding: 8px 5px; font-size: 0.9rem; }
        .log-table tr:hover { background: #111; color: #fff; }
        .win-p1 { color: var(--p1-hex); }
        .win-p2 { color: var(--p2-hex); }

        .terminal-controls { padding: 10px; border-top: 1px solid #333; display: flex; gap: 10px; }
        
        #export-area { width: 100%; height: 100px; background: #111; border: 1px solid #333; color: var(--accent-hex); font-size: 0.8rem; margin-top: 10px; display: none; }

        @media (max-width: 900px) {
            #game-ui { grid-template-columns: 1fr; grid-template-rows: auto 1fr auto; padding: 10px; }
            .sidebar { flex-direction: row; padding: 10px; gap: 10px; justify-content: space-around; }
            .stat-val { font-size: 2rem; }
            h1 { font-size: 2.5rem; }
        }
    </style>
</head>
<body>

    <canvas id="vfx-canvas"></canvas>

    <div id="setup-screen" class="glass-panel">
        <h1>AGGRESSION</h1>
        <div style="letter-spacing: 3px; color: var(--accent-hex); margin-bottom: 20px;">OMEGA PROTOCOL</div>

        <div class="config-row">
            <div style="width: 50%;">
                <label>GRID CONFIG</label>
                <div style="display: flex; gap: 5px;">
                    <input type="number" id="rows" value="6" min="3" max="10" placeholder="R">
                    <input type="number" id="cols" value="6" min="3" max="10" placeholder="C">
                </div>
            </div>
            <div style="width: 50%;">
                <label>UNIT CAP</label>
                <input type="number" id="troops" value="36">
            </div>
        </div>

        <div style="width: 100%;">
            <label>TACTICAL OPPONENT</label>
            <select id="opponent">
                <option value="human">HUMAN VS HUMAN</option>
                <option value="weak">AI: TRAINEE (Random)</option>
                <option value="strategic">AI: TACTICIAN (Clustering)</option>
                <option value="minimax">AI: OMEGA (Minimax - Advanced)</option>
            </select>
        </div>

        <button class="btn" style="width: 100%; margin-top: 10px;" onclick="Game.init()">INITIALIZE SIMULATION</button>
        <button class="btn btn-danger" style="width: 100%;" onclick="DataMgr.openTerminal()">MISSION ARCHIVES / SYNC</button>
    </div>

    <div id="game-ui">
        <div class="sidebar glass-panel p1-color" id="p1-panel">
            <div style="font-family: Orbitron; font-weight: bold; font-size: 1.5rem; text-align: center;">PLAYER 1</div>
            <div class="stat-display">
                <div class="stat-val" id="p1-reserves">0</div>
                <div class="stat-label">RESERVES</div>
            </div>
            <div class="stat-display">
                <div class="stat-val" id="p1-score">0</div>
                <div class="stat-label">SECTORS</div>
            </div>
        </div>

        <div id="center-view">
            <div id="phase-bar">PLACEMENT PHASE</div>
            <div id="board-wrapper">
                <div id="grid"></div>
            </div>
            
            <div id="controls">
                <div id="place-ui" style="display:flex; gap:10px; align-items:center;">
                    <input type="number" id="deploy-amt" value="1" min="1" style="width: 70px;">
                    <span style="color: #666; font-size: 0.8rem;">UNITS</span>
                </div>
                <button id="pass-btn" class="btn btn-danger" style="display:none;" onclick="Game.passTurn()">SKIP TURN</button>
            </div>
        </div>

        <div class="sidebar glass-panel p2-color" id="p2-panel">
            <div style="font-family: Orbitron; font-weight: bold; font-size: 1.5rem; text-align: center;" id="p2-title">PLAYER 2</div>
            <div class="stat-display">
                <div class="stat-val" id="p2-reserves">0</div>
                <div class="stat-label">RESERVES</div>
            </div>
            <div class="stat-display">
                <div class="stat-val" id="p2-score">0</div>
                <div class="stat-label">SECTORS</div>
            </div>
        </div>
    </div>

    <div id="terminal-modal" class="modal-overlay">
        <div class="terminal">
            <div class="terminal-header">
                <span>:: MISSION DATA ARCHIVE ::</span>
                <span style="cursor:pointer;" onclick="DataMgr.closeTerminal()">[X]</span>
            </div>
            <div class="terminal-body">
                <p>LOCAL STORAGE RECORD:</p>
                <table class="log-table">
                    <thead><tr><th>ID</th><th>DATE</th><th>WINNER</th><th>SCORE</th><th>ACTION</th></tr></thead>
                    <tbody id="archive-table-body"></tbody>
                </table>
                <textarea id="export-area" readonly placeholder="Sync Data will appear here..."></textarea>
            </div>
            <div class="terminal-controls">
                <button class="btn" style="font-size: 0.8rem;" onclick="DataMgr.exportData()">EXPORT SYNC CODE</button>
                <button class="btn" style="font-size: 0.8rem;" onclick="DataMgr.importData()">IMPORT SYNC CODE</button>
                <div style="flex:1"></div>
                <button class="btn btn-danger" style="font-size: 0.8rem;" onclick="DataMgr.wipeData()">PURGE DB</button>
            </div>
        </div>
    </div>

    <script>
        /* --- AUDIO SYSTEM --- */
        const Sfx = {
            ctx: new (window.AudioContext || window.webkitAudioContext)(),
            playTone: function(freq, type, duration) {
                if(this.ctx.state === 'suspended') this.ctx.resume();
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = type;
                osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
                gain.gain.setValueAtTime(0.1, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);
                osc.connect(gain);
                gain.connect(this.ctx.destination);
                osc.start();
                osc.stop(this.ctx.currentTime + duration);
            },
            click: () => Sfx.playTone(800, 'square', 0.1),
            error: () => Sfx.playTone(150, 'sawtooth', 0.3),
            place: () => Sfx.playTone(400, 'sine', 0.2),
            attack: () => { Sfx.playTone(100, 'sawtooth', 0.1); setTimeout(()=>Sfx.playTone(60, 'square', 0.4), 100); },
            win: () => { 
                [300, 400, 500, 600, 800].forEach((f, i) => setTimeout(() => Sfx.playTone(f, 'square', 0.2), i*100)); 
            }
        };

        /* --- VISUAL FX SYSTEM --- */
        const Vfx = {
            canvas: document.getElementById('vfx-canvas'),
            ctx: document.getElementById('vfx-canvas').getContext('2d'),
            particles: [],
            resize: function() { this.canvas.width = window.innerWidth; this.canvas.height = window.innerHeight; },
            spawn: function(x, y, color, count) {
                for(let i=0; i<count; i++) {
                    this.particles.push({
                        x: x, y: y,
                        vx: (Math.random() - 0.5) * 10,
                        vy: (Math.random() - 0.5) * 10,
                        life: 1.0,
                        color: color
                    });
                }
            },
            loop: function() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                for(let i=this.particles.length-1; i>=0; i--) {
                    let p = this.particles[i];
                    p.x += p.vx; p.y += p.vy; p.life -= 0.02;
                    this.ctx.globalAlpha = p.life;
                    this.ctx.fillStyle = p.color;
                    this.ctx.beginPath();
                    this.ctx.arc(p.x, p.y, 3, 0, Math.PI*2);
                    this.ctx.fill();
                    if(p.life <= 0) this.particles.splice(i, 1);
                }
                requestAnimationFrame(() => this.loop());
            }
        };
        window.addEventListener('resize', () => Vfx.resize());
        Vfx.resize(); Vfx.loop();

        /* --- DATA MANAGER (PERSISTENCE) --- */
        const DataMgr = {
            key: 'aggression_omega_db',
            getHistory: function() {
                const raw = localStorage.getItem(this.key);
                return raw ? JSON.parse(raw) : [];
            },
            saveGame: function(winner, score, detailedLog) {
                const db = this.getHistory();
                db.unshift({
                    id: Date.now().toString(36),
                    timestamp: new Date().toLocaleString(),
                    winner: winner,
                    score: score,
                    log: detailedLog
                });
                localStorage.setItem(this.key, JSON.stringify(db));
            },
            openTerminal: function() {
                document.getElementById('terminal-modal').style.display = 'flex';
                this.renderTable();
            },
            closeTerminal: function() { document.getElementById('terminal-modal').style.display = 'none'; },
            renderTable: function() {
                const db = this.getHistory();
                const tbody = document.getElementById('archive-table-body');
                tbody.innerHTML = '';
                if(db.length === 0) { tbody.innerHTML = '<tr><td colspan="5" style="text-align:center">NO RECORDS FOUND</td></tr>'; return; }
                
                db.forEach(entry => {
                    const tr = document.createElement('tr');
                    const wClass = entry.winner.includes('1') ? 'win-p1' : (entry.winner.includes('2') ? 'win-p2' : '');
                    tr.innerHTML = `
                        <td>${entry.id}</td>
                        <td>${entry.timestamp}</td>
                        <td class="${wClass}">${entry.winner}</td>
                        <td>${entry.score}</td>
                        <td><button style="font-size:0.7rem; cursor:pointer;" onclick="DataMgr.downloadLog('${entry.id}')">DOWNLOAD</button></td>
                    `;
                    tbody.appendChild(tr);
                });
            },
            downloadLog: function(id) {
                const db = this.getHistory();
                const entry = db.find(e => e.id === id);
                if(!entry) return;
                const blob = new Blob([JSON.stringify(entry, null, 2)], {type: 'application/json'});
                const a = document.createElement('a');
                a.href = URL.createObjectURL(blob);
                a.download = `mission_${entry.id}.json`;
                a.click();
            },
            exportData: function() {
                const raw = localStorage.getItem(this.key) || "[]";
                // Simple Base64 encode for easy copy/paste
                const encoded = btoa(unescape(encodeURIComponent(raw))); 
                const area = document.getElementById('export-area');
                area.style.display = 'block';
                area.value = encoded;
                area.select();
                alert("DATA ENCODED. COPY THE TEXT BELOW TO TRANSFER.");
            },
            importData: function() {
                const input = prompt("PASTE SYNC CODE HERE:");
                if(!input) return;
                try {
                    const decoded = decodeURIComponent(escape(atob(input)));
                    JSON.parse(decoded); // Validate JSON
                    if(confirm("WARNING: This will overwrite local data. Proceed?")) {
                        localStorage.setItem(this.key, decoded);
                        this.renderTable();
                        alert("IMPORT SUCCESSFUL.");
                    }
                } catch(e) { alert("INVALID DATA CORRUPTION DETECTED."); }
            },
            wipeData: function() {
                if(confirm("CONFIRM PURGE? This cannot be undone.")) {
                    localStorage.removeItem(this.key);
                    this.renderTable();
                }
            }
        };

        /* --- OMEGA AI (MINIMAX) --- */
        const AI = {
            evaluate: function(grid, p1Res, p2Res, phase) {
                let score = 0;
                let myArea = 0, enArea = 0;
                let myTroops = 0, enTroops = 0;
                let clusters = 0;

                for(let r=0; r<grid.length; r++) {
                    for(let c=0; c<grid[0].length; c++) {
                        const cell = grid[r][c];
                        if(cell.owner === 2) {
                            myArea++;
                            myTroops += cell.count;
                            // Cluster bonus
                            for(let dr=-1; dr<=1; dr++) {
                                for(let dc=-1; dc<=1; dc++) {
                                    if(dr===0 && dc===0) continue;
                                    let nr=r+dr, nc=c+dc;
                                    if(nr>=0 && nr<grid.length && nc>=0 && nc<grid[0].length) {
                                        if(grid[nr][nc].owner === 2) clusters++;
                                    }
                                }
                            }
                        } else if(cell.owner === 1) {
                            enArea++;
                            enTroops += cell.count;
                        }
                    }
                }

                if(phase === 'placement') {
                    // Prioritize efficient stacking and safe expansion
                    score += (myTroops * 10) + (clusters * 5) - (enArea * 20);
                } else {
                    // Attack phase: Material difference is king
                    score += (myArea * 100) - (enArea * 100);
                    score += (myTroops * 5); // Tie breaker
                }
                return score;
            },
            // Simulate Attack move
            getBestAttack: function(state) {
                // Find all possible attacks
                let bestMove = null;
                let bestVal = -Infinity;
                let possibleMoves = [];

                for(let r=0; r<state.rows; r++) {
                    for(let c=0; c<state.cols; c++) {
                        if(state.grid[r][c].owner === 1) { // Enemy
                            let power = 0;
                            // Check power
                             for(let dr=-1; dr<=1; dr++) {
                                for(let dc=-1; dc<=1; dc++) {
                                    if(dr===0 && dc===0) continue;
                                    let nr=r+dr, nc=c+dc;
                                    if(nr>=0 && nr<state.rows && nc>=0 && nc<state.cols) {
                                        if(state.grid[nr][nc].owner === 2) power += state.grid[nr][nc].count;
                                    }
                                }
                            }
                            if(power > state.grid[r][c].count) {
                                // This is a legal move
                                let score = state.grid[r][c].count * 10; // Value of kill
                                // Add strategic value of the cell (center control)
                                let centerDist = Math.abs(r - state.rows/2) + Math.abs(c - state.cols/2);
                                score -= centerDist;
                                possibleMoves.push({r, c, score});
                            }
                        }
                    }
                }
                
                if(possibleMoves.length > 0) {
                    possibleMoves.sort((a,b) => b.score - a.score);
                    return possibleMoves[0]; // Greedy best kill
                }
                return null; // Pass
            },
            // Improved Placement Logic
            getPlacement: function(state) {
                // Minimax is too slow for placement due to branching factor
                // Use Advanced Heuristic
                let best = {r:0, c:0, score:-Infinity};
                
                for(let r=0; r<state.rows; r++) {
                    for(let c=0; c<state.cols; c++) {
                        if(state.grid[r][c].owner === 1) continue;
                        
                        let score = 0;
                        // Neighbors
                        let nFriends=0, nEnemies=0;
                         for(let dr=-1; dr<=1; dr++) {
                                for(let dc=-1; dc<=1; dc++) {
                                    if(dr===0 && dc===0) continue;
                                    let nr=r+dr, nc=c+dc;
                                    if(nr>=0 && nr<state.rows && nc>=0 && nc<state.cols) {
                                        if(state.grid[nr][nc].owner === 2) nFriends++;
                                        if(state.grid[nr][nc].owner === 1) nEnemies++;
                                    }
                                }
                        }
                        
                        score += (nFriends * 5); // Cluster heavily
                        score -= (nEnemies * 2); // Avoid immediate danger unless reinforcing
                        if(state.grid[r][c].owner === 2) score += 10; // Reinforce existing
                        if(state.grid[r][c].owner === 0 && nEnemies === 0) score += 2; // Safe expansion
                        
                        // Center bias
                        let dist = Math.abs(r - state.rows/2) + Math.abs(c - state.cols/2);
                        score -= dist;

                        if(score > best.score) best = {r, c, score};
                    }
                }
                return best;
            }
        };

        /* --- GAME ENGINE --- */
        const Game = {
            rows: 0, cols: 0, grid: [],
            p1Res: 0, p2Res: 0,
            turn: 1, phase: 'setup', ai: null,
            firstMover: 0, hasMoved: false, passCount: 0,
            log: [],

            init: function() {
                this.rows = parseInt(document.getElementById('rows').value);
                this.cols = parseInt(document.getElementById('cols').value);
                const t = parseInt(document.getElementById('troops').value);
                const ai = document.getElementById('opponent').value;
                
                if(this.rows < 3) this.rows=3; if(this.rows>10) this.rows=10;
                if(this.cols < 3) this.cols=3; if(this.cols>10) this.cols=10;

                this.p1Res = t; this.p2Res = t;
                this.ai = ai === 'human' ? null : ai;
                this.phase = 'placement';
                this.turn = Math.random() < 0.5 ? 1 : 2;
                this.firstMover = 0; this.hasMoved = false; this.passCount = 0;
                this.log = [];

                this.grid = [];
                for(let r=0; r<this.rows; r++) {
                    let row = [];
                    for(let c=0; c<this.cols; c++) row.push({owner: 0, count: 0});
                    this.grid.push(row);
                }

                document.getElementById('setup-screen').style.display = 'none';
                document.getElementById('game-ui').style.display = 'grid';
                document.getElementById('p2-title').innerText = this.ai ? "AI: " + this.ai.toUpperCase() : "PLAYER 2";

                this.buildBoard();
                this.updateHUD();
                Sfx.click();
                this.logEvent("SYSTEM INITIALIZED");
                this.checkAI();
            },

            buildBoard: function() {
                const el = document.getElementById('grid');
                el.style.gridTemplateColumns = `repeat(${this.cols}, 1fr)`;
                el.innerHTML = '';
                for(let r=0; r<this.rows; r++) {
                    for(let c=0; c<this.cols; c++) {
                        const cell = document.createElement('div');
                        cell.className = 'cell';
                        cell.id = `c-${r}-${c}`;
                        cell.onclick = () => this.handleInput(r, c);
                        el.appendChild(cell);
                    }
                }
            },

            handleInput: function(r, c) {
                if(this.phase === 'over' || (this.ai && this.turn === 2)) return;
                
                if(this.phase === 'placement') {
                    const amt = parseInt(document.getElementById('deploy-amt').value) || 1;
                    this.actionPlace(r, c, amt);
                } else {
                    this.actionAttack(r, c);
                }
            },

            actionPlace: function(r, c, amt) {
                const cell = this.grid[r][c];
                const res = this.turn === 1 ? this.p1Res : this.p2Res;
                if(cell.owner !== 0 && cell.owner !== this.turn) { Sfx.error(); return; }
                
                const actual = Math.min(amt, res);
                if(actual <= 0) return;

                cell.owner = this.turn;
                cell.count += actual;
                if(this.turn === 1) this.p1Res -= actual; else this.p2Res -= actual;
                
                if(!this.hasMoved) {
                    this.hasMoved = true;
                    this.firstMover = this.turn;
                    this.logEvent(`P${this.turn} TOOK INITIATIVE`);
                }

                // Vfx
                const rect = document.getElementById(`c-${r}-${c}`).getBoundingClientRect();
                Vfx.spawn(rect.left + rect.width/2, rect.top + rect.height/2, this.turn === 1 ? '#00f3ff' : '#ff003c', 5);
                Sfx.place();

                this.render();
                this.updateHUD();
                this.checkPhase();
            },

            checkPhase: function() {
                if(this.p1Res === 0 && this.p2Res === 0) {
                    this.phase = 'attack';
                    this.turn = this.firstMover;
                    document.getElementById('phase-bar').innerText = "COMBAT PHASE // ATTACK";
                    document.getElementById('phase-bar').style.color = "#ff003c";
                    document.getElementById('place-ui').style.display = 'none';
                    document.getElementById('pass-btn').style.display = 'block';
                    this.logEvent("COMBAT PHASE INITIATED");
                } else {
                    const next = this.turn === 1 ? 2 : 1;
                    const nextRes = next === 1 ? this.p1Res : this.p2Res;
                    if(nextRes > 0) this.turn = next;
                }
                this.updateHUD();
                this.checkAI();
            },

            actionAttack: function(r, c) {
                const cell = this.grid[r][c];
                if(cell.owner === 0 || cell.owner === this.turn) { Sfx.error(); return; }

                let power = 0;
                 for(let dr=-1; dr<=1; dr++) {
                    for(let dc=-1; dc<=1; dc++) {
                        if(dr===0 && dc===0) continue;
                        let nr=r+dr, nc=c+dc;
                        if(nr>=0 && nr<this.rows && nc>=0 && nc<this.cols) {
                            if(this.grid[nr][nc].owner === this.turn) power += this.grid[nr][nc].count;
                        }
                    }
                }

                if(power > cell.count) {
                    // Success
                    const rect = document.getElementById(`c-${r}-${c}`).getBoundingClientRect();
                    Vfx.spawn(rect.left + rect.width/2, rect.top + rect.height/2, '#ffaa00', 20);
                    Sfx.attack();
                    cell.owner = 0; cell.count = 0;
                    this.passCount = 0;
                    this.logEvent(`P${this.turn} NEUTRALIZED [${r},${c}]`);
                } else {
                    Sfx.error();
                    this.logEvent(`P${this.turn} ATTACK FAILED`);
                }

                this.render();
                this.switchTurn();
            },

            passTurn: function() {
                this.passCount++;
                this.logEvent(`P${this.turn} PASS`);
                if(this.passCount >= 2) this.endGame();
                else this.switchTurn();
            },

            switchTurn: function() {
                this.turn = this.turn === 1 ? 2 : 1;
                this.updateHUD();
                this.checkAI();
            },

            /* --- AI CONTROLLER --- */
            checkAI: function() {
                if(!this.ai || this.turn === 1 || this.phase === 'over') return;
                
                setTimeout(() => {
                    if(this.phase === 'placement') {
                        let move = {r:0, c:0};
                        if(this.ai === 'weak') {
                             move.r = Math.floor(Math.random()*this.rows);
                             move.c = Math.floor(Math.random()*this.cols);
                             // Ensure valid
                             while(this.grid[move.r][move.c].owner === 1) {
                                move.r = Math.floor(Math.random()*this.rows);
                                move.c = Math.floor(Math.random()*this.cols);
                             }
                        } else {
                            move = AI.getPlacement(this);
                        }
                        
                        let amt = 0;
                        if(this.ai === 'weak') amt = Math.floor(Math.random()*5)+1;
                        else amt = Math.floor(Math.random()*3)+2;
                        
                        this.actionPlace(move.r, move.c, amt);
                    } else {
                        // Attack Phase
                        let target = AI.getBestAttack(this);
                        if(target) {
                            this.actionAttack(target.r, target.c);
                        } else {
                            this.passTurn();
                        }
                    }
                }, 800);
            },

            render: function() {
                for(let r=0; r<this.rows; r++) {
                    for(let c=0; c<this.cols; c++) {
                        const el = document.getElementById(`c-${r}-${c}`);
                        const d = this.grid[r][c];
                        el.className = 'cell'; el.innerText = '';
                        if(d.owner === 1) { el.classList.add('p1'); el.innerText = d.count; }
                        if(d.owner === 2) { el.classList.add('p2'); el.innerText = d.count; }
                        
                        // Attack Highlight
                        if(this.phase === 'attack' && this.turn === 1 && d.owner === 2) {
                            let power = 0;
                            for(let dr=-1; dr<=1; dr++) {
                                for(let dc=-1; dc<=1; dc++) {
                                    if(dr===0 && dc===0) continue;
                                    let nr=r+dr, nc=c+dc;
                                    if(nr>=0 && nr<this.rows && nc>=0 && nc<this.cols) {
                                        if(this.grid[nr][nc].owner === 1) power += this.grid[nr][nc].count;
                                    }
                                }
                            }
                            if(power > d.count) el.classList.add('valid-target');
                        }
                    }
                }
            },

            updateHUD: function() {
                document.getElementById('p1-reserves').innerText = this.p1Res;
                document.getElementById('p2-reserves').innerText = this.p2Res;
                document.getElementById('p1-panel').classList.toggle('active', this.turn === 1);
                document.getElementById('p2-panel').classList.toggle('active', this.turn === 2);
                
                let p1s = 0, p2s = 0;
                this.grid.forEach(r => r.forEach(c => {
                    if(c.owner === 1) p1s++;
                    if(c.owner === 2) p2s++;
                }));
                document.getElementById('p1-score').innerText = p1s;
                document.getElementById('p2-score').innerText = p2s;
            },

            logEvent: function(msg) {
                this.log.push(`[${new Date().toLocaleTimeString()}] ${msg}`);
            },

            endGame: function() {
                this.phase = 'over';
                let p1 = parseInt(document.getElementById('p1-score').innerText);
                let p2 = parseInt(document.getElementById('p2-score').innerText);
                let winner = p1 > p2 ? "PLAYER 1" : (p2 > p1 ? "PLAYER 2" : "DRAW");
                
                Sfx.win();
                DataMgr.saveGame(winner, `${p1} - ${p2}`, this.log);
                
                setTimeout(() => {
                    alert(`MISSION COMPLETE\nVICTOR: ${winner}\nFINAL SCORE: ${p1} - ${p2}\n\nData archived to local terminal.`);
                    location.reload();
                }, 1000);
            }
        };
    </script>
</body>
</html>
