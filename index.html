<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Aggression - Tactical Warfare</title>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Rajdhani:wght@500;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-deep: #050b14;
            --panel-bg: rgba(16, 24, 39, 0.85); /* Glass effect */
            --text-main: #e2e8f0;
            --text-muted: #64748b;
            
            /* NEON PALETTE */
            --p1-color: #00f2ff; /* Cyan */
            --p1-glow: rgba(0, 242, 255, 0.6);
            --p2-color: #ff0055; /* Neon Red */
            --p2-glow: rgba(255, 0, 85, 0.6);
            --accent: #00ff9d; /* Matrix Green */
            --border: rgba(255, 255, 255, 0.1);
        }

        * { box-sizing: border-box; }

        body {
            font-family: 'Rajdhani', sans-serif;
            background-color: var(--bg-deep);
            color: var(--text-main);
            margin: 0;
            height: 100vh;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            background-image: 
                linear-gradient(rgba(0, 255, 157, 0.03) 1px, transparent 1px),
                linear-gradient(90deg, rgba(0, 255, 157, 0.03) 1px, transparent 1px);
            background-size: 40px 40px;
            animation: scrollGrid 100s linear infinite;
        }

        @keyframes scrollGrid { from { background-position: 0 0; } to { background-position: 40px 40px; } }

        /* --- LAYOUT GRID --- */
        #main-layout {
            display: grid;
            grid-template-columns: 280px 1fr 280px; /* Left Sidebar | Board | Right Sidebar */
            width: 100%;
            height: 100%;
            padding: 20px;
            gap: 20px;
            position: relative;
            z-index: 10;
        }

        /* --- SIDEBARS (PLAYER STATS) --- */
        .sidebar {
            background: var(--panel-bg);
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 20px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            backdrop-filter: blur(10px);
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
            transition: all 0.3s;
        }

        .sidebar.active-turn {
            border-color: currentColor;
            box-shadow: 0 0 30px currentColor;
            transform: scale(1.02);
        }

        .p1-side { color: var(--p1-color); }
        .p2-side { color: var(--p2-color); }

        .player-title {
            font-family: 'Orbitron', sans-serif;
            font-size: 1.8rem;
            font-weight: 900;
            text-transform: uppercase;
            text-align: center;
            margin-bottom: 30px;
            letter-spacing: 2px;
            text-shadow: 0 0 10px currentColor;
        }

        .stat-box {
            background: rgba(0,0,0,0.3);
            margin-bottom: 20px;
            padding: 15px;
            border-radius: 8px;
            text-align: center;
            border-left: 4px solid currentColor;
        }

        .stat-label { font-size: 0.9rem; opacity: 0.8; letter-spacing: 1px; text-transform: uppercase; }
        .stat-value { font-family: 'Orbitron', sans-serif; font-size: 2.5rem; font-weight: bold; margin-top: 5px; }

        /* --- CENTER AREA (BOARD) --- */
        #center-stage {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        #phase-display {
            font-family: 'Orbitron', sans-serif;
            font-size: 1.5rem;
            color: var(--accent);
            text-transform: uppercase;
            letter-spacing: 4px;
            margin-bottom: 20px;
            text-shadow: 0 0 10px var(--accent);
            background: rgba(0, 255, 157, 0.1);
            padding: 10px 30px;
            border-radius: 4px;
            border: 1px solid var(--accent);
        }

        #board-frame {
            padding: 10px;
            background: rgba(0,0,0,0.5);
            border-radius: 12px;
            border: 1px solid var(--border);
            box-shadow: 0 20px 50px rgba(0,0,0,0.8);
        }

        #grid { display: grid; gap: 6px; }

        .cell {
            width: 60px; height: 60px;
            background: #111;
            border-radius: 4px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-family: 'Orbitron', sans-serif;
            font-size: 1.4rem;
            font-weight: bold;
            cursor: pointer;
            border: 1px solid #333;
            color: white;
            position: relative;
            transition: all 0.2s;
        }
        .cell:hover { border-color: white; box-shadow: 0 0 15px rgba(255,255,255,0.2); z-index: 2; transform: scale(1.1); }
        
        .cell.p1 { 
            background: rgba(0, 242, 255, 0.15); 
            border: 2px solid var(--p1-color); 
            color: var(--p1-color);
            box-shadow: inset 0 0 20px var(--p1-glow);
        }
        .cell.p2 { 
            background: rgba(255, 0, 85, 0.15); 
            border: 2px solid var(--p2-color); 
            color: var(--p2-color);
            box-shadow: inset 0 0 20px var(--p2-glow);
        }

        .cell.valid-target {
            animation: targetPulse 1s infinite;
            cursor: crosshair;
        }
        @keyframes targetPulse { 0% { box-shadow: 0 0 0 var(--p2-color); } 50% { box-shadow: 0 0 20px var(--p2-color); border-color: white; } 100% { box-shadow: 0 0 0 var(--p2-color); } }

        /* --- CONTROLS --- */
        #control-panel {
            margin-top: 20px;
            display: flex;
            gap: 15px;
            align-items: center;
            background: var(--panel-bg);
            padding: 15px 30px;
            border-radius: 50px;
            border: 1px solid var(--border);
        }

        input[type="number"] {
            background: transparent; border: 1px solid var(--text-muted); color: var(--accent);
            padding: 8px; border-radius: 4px; width: 70px; text-align: center; font-size: 1.2rem; font-family: 'Orbitron';
        }

        .btn {
            background: var(--accent); color: black; border: none; padding: 10px 25px;
            font-family: 'Rajdhani', sans-serif; font-weight: 800; font-size: 1.1rem; text-transform: uppercase;
            border-radius: 4px; cursor: pointer; transition: all 0.2s; clip-path: polygon(10% 0, 100% 0, 100% 90%, 90% 100%, 0 100%, 0 10%);
        }
        .btn:hover { transform: translateY(-2px); box-shadow: 0 0 15px var(--accent); background: white; }
        
        .btn-outline { background: transparent; border: 1px solid var(--text-muted); color: var(--text-muted); }
        .btn-outline:hover { border-color: white; color: white; box-shadow: none; }

        /* --- LOG & HELP --- */
        #log-container {
            position: absolute; bottom: 20px; right: 20px; width: 300px; height: 150px;
            z-index: 50; pointer-events: none; /* Let clicks pass through */
        }
        #log-area {
            width: 100%; height: 100%;
            overflow-y: hidden;
            display: flex; flex-direction: column-reverse; /* Newest at bottom visually */
        }
        .log-entry {
            background: rgba(0,0,0,0.7); padding: 5px 10px; margin-top: 4px;
            font-size: 0.85rem; border-left: 3px solid var(--text-muted);
            animation: slideIn 0.3s ease-out; pointer-events: auto;
            color: #ccc;
        }
        .log-entry.highlight { border-color: var(--accent); color: var(--accent); }
        .log-entry.error { border-color: var(--p2-color); color: var(--p2-color); }
        @keyframes slideIn { from { transform: translateX(20px); opacity: 0; } to { transform: translateX(0); opacity: 1; } }

        #help-btn {
            position: absolute; top: 20px; right: 20px;
            width: 40px; height: 40px; border-radius: 50%;
            background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.2);
            color: white; font-weight: bold; cursor: pointer; font-size: 1.2rem;
            display: flex; align-items: center; justify-content: center;
            z-index: 100;
        }
        #help-btn:hover { background: var(--accent); color: black; border-color: var(--accent); }

        /* --- MODALS --- */
        .modal-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 5, 10, 0.95);
            display: none; justify-content: center; align-items: center; z-index: 9999;
        }
        .modal-content {
            background: #0f172a; padding: 40px; max-width: 600px; width: 90%;
            border: 1px solid var(--accent); border-radius: 8px;
            box-shadow: 0 0 50px rgba(0, 255, 157, 0.2);
            position: relative;
        }
        .close-btn { position: absolute; top: 15px; right: 15px; background: none; border: none; color: white; font-size: 1.5rem; cursor: pointer; }
        
        h2 { color: var(--accent); font-family: 'Orbitron'; text-transform: uppercase; margin-bottom: 20px; border-bottom: 1px solid #333; padding-bottom: 10px; }
        p, li { line-height: 1.6; color: #cbd5e1; }
        strong { color: white; }

        /* Setup Screen Styling */
        #setup-screen { text-align: center; }
        #setup-screen input, #setup-screen select {
            background: #1e293b; border: 1px solid #475569; color: white;
            padding: 12px; border-radius: 4px; width: 100%; margin-bottom: 20px;
            font-family: 'Rajdhani'; font-size: 1.1rem;
        }
        #setup-screen label { display: block; text-align: left; margin-bottom: 5px; color: var(--accent); font-size: 0.9rem; }

        @media (max-width: 900px) {
            #main-layout { grid-template-columns: 1fr; grid-template-rows: auto auto auto; overflow-y: auto; display: flex; flex-direction: column; }
            .sidebar { flex-direction: row; justify-content: space-around; padding: 10px; }
            .player-title { font-size: 1.2rem; margin: 0; display: flex; align-items: center; }
            .stat-box { margin: 0; padding: 5px 15px; }
            .stat-value { font-size: 1.5rem; }
            #log-container { display: none; } /* Hide log on mobile to save space */
        }
    </style>
</head>
<body>

    <div id="rules-modal" class="modal-overlay">
        <div class="modal-content">
            <button class="close-btn" onclick="toggleRules()">Ã—</button>
            <h2>How to Play</h2>
            
            <div style="margin-bottom: 20px;">
                <h3 style="color: var(--p1-color)">Phase 1: Placement</h3>
                <p>Players take turns placing troops on the board.</p>
                <ul>
                    <li>You can place multiple troops on a single tile.</li>
                    <li><strong>Strategy:</strong> Stack troops together to create strongholds.</li>
                </ul>
            </div>

            <div style="margin-bottom: 20px;">
                <h3 style="color: var(--p2-color)">Phase 2: Attack</h3>
                <p>The player who placed the <strong>very first troop</strong> gets to attack first.</p>
                <ul>
                    <li>Click an enemy tile to attack it.</li>
                    <li><strong>The Math:</strong> Add up ALL your troops that surround the target.</li>
                    <li>If <strong>Your Surrounding Sum > Enemy Stack</strong>, the enemy is removed.</li>
                </ul>
            </div>

            <div>
                <h3 style="color: var(--accent)">AI Personalities</h3>
                <ul style="list-style: none; padding: 0;">
                    <li style="margin-bottom: 8px;"><strong style="color: #999">Weak AI:</strong> Moves completely randomly. Useful for learning the mechanics.</li>
                    <li style="margin-bottom: 8px;"><strong style="color: #ea580c">Strategic AI:</strong> Tries to group troops together (clustering) and targets your largest stacks.</li>
                    <li><strong style="color: var(--accent)">Smart AI:</strong> Calculates "Threat Levels." It defends areas where it is vulnerable and attacks your most dangerous units.</li>
                </ul>
            </div>
            <br>
            <button class="btn" style="width:100%" onclick="toggleRules()">INITIATE</button>
        </div>
    </div>

    <div id="game-over-modal" class="modal-overlay">
        <div class="modal-content" style="text-align: center;">
            <h2 id="winner-display" style="font-size: 3rem; border: none;">PLAYER 1 WINS</h2>
            <div id="final-score" style="font-size: 1.5rem; margin-bottom: 30px; font-family: 'Orbitron';">P1: 15 - P2: 12</div>
            
            <button class="btn" onclick="restartGame()">RE-DEPLOY</button>
            <button class="btn btn-outline" style="margin-top: 10px; width: 100%" onclick="returnToMenu()">MAIN MENU</button>
            <button class="btn btn-outline" style="margin-top: 10px; width: 100%" onclick="downloadLog()">SAVE LOG DATA</button>
        </div>
    </div>

    <div id="setup-screen" class="modal-overlay" style="display: flex;">
        <div class="modal-content">
            <h1 style="font-family: 'Orbitron'; font-size: 3rem; margin-bottom: 0; color: white;">AGGRESSION</h1>
            <p style="color: var(--accent); margin-bottom: 30px; letter-spacing: 2px;">TACTICAL WARFARE SIMULATOR</p>

            <label>GRID CONFIGURATION</label>
            <div style="display: flex; gap: 15px;">
                <input type="number" id="rows" value="6" min="3" max="10" placeholder="Rows">
                <input type="number" id="cols" value="6" min="3" max="10" placeholder="Cols">
            </div>

            <label>UNIT ALLOCATION (PER PLAYER)</label>
            <input type="number" id="troops" value="36" min="1">
            
            <label>OPPONENT PROTOCOL</label>
            <select id="opponent">
                <option value="human">Human vs Human</option>
                <option value="weak">AI: Weak (Random)</option>
                <option value="strategic">AI: Strategic (Clustering)</option>
                <option value="smart" selected>AI: Smart (Heuristic)</option>
            </select>

            <button class="btn" style="width: 100%; font-size: 1.2rem; margin-top: 10px;" onclick="startGame()">INITIALIZE SYSTEM</button>
            <button class="btn btn-outline" style="width: 100%; margin-top: 10px; border:none;" onclick="toggleRules()">READ PROTOCOLS</button>
        </div>
    </div>

    <button id="help-btn" onclick="toggleRules()">?</button>
    <div id="log-container"><div id="log-area"></div></div>

    <div id="main-layout" style="display: none;"> <div class="sidebar p1-side" id="p1-sidebar">
            <div class="player-title">PLAYER 1</div>
            <div class="stat-box">
                <div class="stat-label">RESERVES</div>
                <div class="stat-value" id="p1-reserves">0</div>
            </div>
            <div class="stat-box">
                <div class="stat-label">TERRITORY</div>
                <div class="stat-value" id="p1-score">0</div>
            </div>
        </div>

        <div id="center-stage">
            <div id="phase-display">PLACEMENT PHASE</div>
            
            <div id="board-frame">
                <div id="grid"></div>
            </div>

            <div id="control-panel">
                <div id="placement-ctrls" style="display: flex; align-items: center; gap: 10px;">
                    <span style="color: var(--text-muted); font-weight: bold;">DEPLOY:</span>
                    <input type="number" id="amount-input" value="1" min="1">
                </div>
                
                <div id="attack-ctrls" style="display: none;">
                    <span style="color: var(--text-muted); font-weight: bold; margin-right: 10px;">TARGET HOSTILE</span>
                    <button class="btn btn-outline" onclick="passTurn()">PASS TURN</button>
                </div>
            </div>
        </div>

        <div class="sidebar p2-side" id="p2-sidebar">
            <div class="player-title" id="p2-name-display">PLAYER 2</div>
            <div class="stat-box">
                <div class="stat-label">RESERVES</div>
                <div class="stat-value" id="p2-reserves">0</div>
            </div>
            <div class="stat-box">
                <div class="stat-label">TERRITORY</div>
                <div class="stat-value" id="p2-score">0</div>
            </div>
        </div>

    </div>

    <script>
        /* --- GAME ENGINE --- */
        const Game = {
            rows: 0, cols: 0, grid: [],
            p1Reserves: 0, p2Reserves: 0,
            turn: 1, phase: 'placement', aiType: null, 
            firstPlayerToPlace: 0, hasFirstMoveHappened: false,
            passCount: 0, isAiProcessing: false,
            logHistory: []
        };

        // --- UI UTILS ---
        function toggleRules() {
            const modal = document.getElementById('rules-modal');
            modal.style.display = (modal.style.display === 'flex') ? 'none' : 'flex';
        }

        function log(msg, type='neutral') {
            const area = document.getElementById('log-area');
            const entry = document.createElement('div');
            entry.className = `log-entry ${type}`;
            const time = new Date().toLocaleTimeString([], { hour12: false, hour: '2-digit', minute: '2-digit', second: '2-digit' });
            entry.innerText = `[${time}] ${msg}`;
            area.appendChild(entry); // Add to bottom
            area.scrollTop = area.scrollHeight; // Auto scroll
            Game.logHistory.push(`[${time}] ${msg}`);
        }

        function downloadLog() {
            if(Game.logHistory.length === 0) return;
            let content = `AGGRESSION GAME LOG\nGenerated: ${new Date().toLocaleString()}\n------------------------\n`;
            content += Game.logHistory.join('\n');
            const blob = new Blob([content], { type: 'text/plain' });
            const a = document.createElement('a');
            a.href = URL.createObjectURL(blob);
            a.download = `aggression_log_${Date.now()}.txt`;
            a.click();
        }

        function updateHUD() {
            document.getElementById('p1-reserves').innerText = Game.p1Reserves;
            document.getElementById('p2-reserves').innerText = Game.p2Reserves;
            
            // Sidebar glow effects
            const s1 = document.getElementById('p1-sidebar');
            const s2 = document.getElementById('p2-sidebar');
            s1.classList.toggle('active-turn', Game.turn === 1);
            s2.classList.toggle('active-turn', Game.turn === 2);

            let p1 = 0, p2 = 0;
            Game.grid.forEach(row => row.forEach(c => {
                if(c.owner === 1) p1++;
                if(c.owner === 2) p2++;
            }));
            document.getElementById('p1-score').innerText = p1;
            document.getElementById('p2-score').innerText = p2;
        }

        // --- INIT ---
        function startGame() {
            Game.rows = parseInt(document.getElementById('rows').value);
            Game.cols = parseInt(document.getElementById('cols').value);
            const troops = parseInt(document.getElementById('troops').value);
            const aiVal = document.getElementById('opponent').value;

            if(Game.rows < 3) Game.rows = 3; if(Game.rows > 10) Game.rows = 10;
            if(Game.cols < 3) Game.cols = 3; if(Game.cols > 10) Game.cols = 10;

            Game.p1Reserves = troops;
            Game.p2Reserves = troops;
            Game.aiType = aiVal === 'human' ? null : aiVal;
            Game.phase = 'placement';
            Game.turn = Math.random() < 0.5 ? 1 : 2; 
            Game.firstPlayerToPlace = 0;
            Game.hasFirstMoveHappened = false;
            Game.passCount = 0;
            Game.isAiProcessing = false;
            Game.logHistory = [];

            // Grid Init
            Game.grid = [];
            for(let r=0; r<Game.rows; r++) {
                let row = [];
                for(let c=0; c<Game.cols; c++) row.push({ owner: 0, count: 0 });
                Game.grid.push(row);
            }

            // UI Reveal
            document.getElementById('setup-screen').style.display = 'none';
            document.getElementById('main-layout').style.display = 'grid'; // Enable Grid Layout
            document.getElementById('game-over-modal').style.display = 'none';
            document.getElementById('log-area').innerHTML = '';
            
            const p2Title = document.getElementById('p2-name-display');
            p2Title.innerText = Game.aiType ? `AI: ${Game.aiType.toUpperCase()}` : "PLAYER 2";

            updatePhaseDisplay("PLACEMENT PHASE");

            buildBoard();
            updateHUD();
            log("SYSTEM INITIALIZED.", "highlight");
            log(`Turn: Player ${Game.turn} (Placement).`);

            checkAI();
        }

        function restartGame() {
            startGame();
        }

        function returnToMenu() {
            document.getElementById('game-over-modal').style.display = 'none';
            document.getElementById('main-layout').style.display = 'none';
            document.getElementById('setup-screen').style.display = 'flex';
        }

        function updatePhaseDisplay(text) {
            const el = document.getElementById('phase-display');
            el.innerText = text;
            if(text.includes("ATTACK")) {
                el.style.color = "var(--p2-color)";
                el.style.borderColor = "var(--p2-color)";
                el.style.background = "rgba(255, 0, 85, 0.1)";
                document.getElementById('placement-ctrls').style.display = 'none';
                document.getElementById('attack-ctrls').style.display = 'flex';
            } else {
                el.style.color = "var(--accent)";
                el.style.borderColor = "var(--accent)";
                el.style.background = "rgba(0, 255, 157, 0.1)";
                document.getElementById('placement-ctrls').style.display = 'flex';
                document.getElementById('attack-ctrls').style.display = 'none';
            }
        }

        function buildBoard() {
            const container = document.getElementById('grid');
            container.style.gridTemplateColumns = `repeat(${Game.cols}, 1fr)`;
            container.innerHTML = '';
            for(let r=0; r<Game.rows; r++) {
                for(let c=0; c<Game.cols; c++) {
                    const d = document.createElement('div');
                    d.className = 'cell';
                    d.id = `cell-${r}-${c}`;
                    d.onclick = () => handleInput(r, c);
                    container.appendChild(d);
                }
            }
        }

        // --- GAME LOGIC ---
        function handleInput(r, c) {
            if(Game.phase === 'gameover' || Game.isAiProcessing) return;
            if(Game.aiType && Game.turn === 2) return;

            if(Game.phase === 'placement') playerPlace(r, c);
            else playerAttack(r, c);
        }

        function playerPlace(r, c) {
            const amt = parseInt(document.getElementById('amount-input').value) || 1;
            const cell = Game.grid[r][c];
            const reserves = Game.turn === 1 ? Game.p1Reserves : Game.p2Reserves;

            if(cell.owner !== 0 && cell.owner !== Game.turn) { log("Target hostile occupied. Invalid.", "error"); return; }
            if(amt > reserves) return; // Silent fail if logic error, visual handled by UI

            // Execute
            const actualAmt = Math.min(amt, reserves);
            cell.owner = Game.turn;
            cell.count += actualAmt;
            if(Game.turn === 1) Game.p1Reserves -= actualAmt; else Game.p2Reserves -= actualAmt;

            if(!Game.hasFirstMoveHappened) {
                Game.firstPlayerToPlace = Game.turn;
                Game.hasFirstMoveHappened = true;
                log(`First move recorded. Player ${Game.turn} gains attack initiative.`, "highlight");
            }

            renderBoard();
            updateHUD();
            checkPhaseTransition();
        }

        function checkPhaseTransition() {
            if(Game.p1Reserves === 0 && Game.p2Reserves === 0) {
                Game.phase = 'attack';
                Game.turn = Game.firstPlayerToPlace;
                updatePhaseDisplay("ATTACK PHASE");
                log("RESERVES DEPLETED. COMBAT PROTOCOLS ENGAGED.", "highlight");
            } else {
                const next = Game.turn === 1 ? 2 : 1;
                const nextRes = next === 1 ? Game.p1Reserves : Game.p2Reserves;
                if(nextRes > 0) Game.turn = next;
                else log(`Player ${next} depleted. Continuing turn.`);
            }
            updateHUD();
            checkAI();
        }

        function playerAttack(r, c) {
            const target = Game.grid[r][c];
            if(target.owner === 0 || target.owner === Game.turn) { log("Invalid Target.", "error"); return; }

            // Calc Power
            let power = 0;
            for(let dr=-1; dr<=1; dr++) {
                for(let dc=-1; dc<=1; dc++) {
                    if(dr===0 && dc===0) continue;
                    let nr = r+dr, nc = c+dc;
                    if(nr>=0 && nr<Game.rows && nc>=0 && nc<Game.cols) {
                        if(Game.grid[nr][nc].owner === Game.turn) power += Game.grid[nr][nc].count;
                    }
                }
            }

            if(power > target.count) {
                log(`Attack [${r},${c}] SUCCESS (${power} vs ${target.count}).`, "highlight");
                target.owner = 0; target.count = 0;
                Game.passCount = 0;
            } else {
                log(`Attack [${r},${c}] FAILED (${power} vs ${target.count}).`, "error");
            }
            
            renderBoard();
            switchTurn();
        }

        function passTurn() {
            log(`Player ${Game.turn} PASS.`);
            Game.passCount++;
            if(Game.passCount >= 2) endGame(); else switchTurn();
        }

        function switchTurn() {
            Game.turn = Game.turn === 1 ? 2 : 1;
            updateHUD();
            checkAI();
        }

        // --- ADVANCED AI ---
        function checkAI() {
            if(!Game.aiType || Game.turn === 1 || Game.phase === 'gameover') return;
            Game.isAiProcessing = true;
            setTimeout(() => {
                Game.phase === 'placement' ? aiPlace() : aiAttack();
                Game.isAiProcessing = false;
                renderBoard();
                updateHUD();
                Game.phase === 'placement' ? checkPhaseTransition() : switchTurn();
            }, 600);
        }

        function getNeighbors(r, c) {
            let n = { friends: 0, enemies: 0, empty: 0 };
            for(let dr=-1; dr<=1; dr++) {
                for(let dc=-1; dc<=1; dc++) {
                    if(dr===0 && dc===0) continue;
                    let nr = r+dr, nc = c+dc;
                    if(nr>=0 && nr<Game.rows && nc>=0 && nc<Game.cols) {
                        let o = Game.grid[nr][nc].owner;
                        if(o === 2) n.friends++;
                        else if(o === 1) n.enemies++;
                        else n.empty++;
                    }
                }
            }
            return n;
        }

        function aiPlace() {
            let moves = [];
            for(let r=0; r<Game.rows; r++) {
                for(let c=0; c<Game.cols; c++) {
                    if(Game.grid[r][c].owner === 1) continue; // Skip P1
                    let score = Math.random(); 
                    
                    if(Game.aiType !== 'weak') {
                        let n = getNeighbors(r, c);
                        // Strategic: Like friends
                        if(Game.aiType === 'strategic') score += (n.friends * 2);
                        
                        // Smart: Complex Heuristic
                        if(Game.aiType === 'smart') {
                            score += (n.friends * 3); // Strong clustering
                            score -= (n.enemies * 1); // Avoid direct contact early if surrounded
                            if(n.enemies === 0) score += 1; // Safe spots
                            
                            // Prefer Center
                            let centerDist = Math.abs(r - Game.rows/2) + Math.abs(c - Game.cols/2);
                            score -= (centerDist * 0.5);
                        }
                    }
                    moves.push({r, c, score});
                }
            }
            
            moves.sort((a,b) => b.score - a.score);
            let best = moves[0] || {r:0, c:0};
            
            // Amount
            let amt = (Game.aiType === 'weak') ? Math.floor(Math.random()*5)+1 : Math.floor(Math.random()*3)+2;
            amt = Math.min(amt, Game.p2Reserves);
            
            // Execute
            let cell = Game.grid[best.r][best.c];
            cell.owner = 2; cell.count += amt; Game.p2Reserves -= amt;
            
            if(!Game.hasFirstMoveHappened) {
                Game.firstPlayerToPlace = 2; Game.hasFirstMoveHappened = true;
                log("AI took initiative.", "highlight");
            }
            log(`AI Deployed ${amt} units at [${best.r},${best.c}].`);
        }

        function aiAttack() {
            let attacks = [];
            for(let r=0; r<Game.rows; r++) {
                for(let c=0; c<Game.cols; c++) {
                    if(Game.grid[r][c].owner === 1) { // Enemy
                        let power = 0;
                        for(let dr=-1; dr<=1; dr++) {
                            for(let dc=-1; dc<=1; dc++) {
                                if(dr===0 && dc===0) continue;
                                let nr = r+dr, nc = c+dc;
                                if(nr>=0 && nr<Game.rows && nc>=0 && nc<Game.cols) {
                                    if(Game.grid[nr][nc].owner === 2) power += Game.grid[nr][nc].count;
                                }
                            }
                        }
                        
                        if(power > Game.grid[r][c].count) {
                            let val = Game.grid[r][c].count; // Value of kill
                            let threat = 0; // How dangerous is this enemy to me?
                            
                            if(Game.aiType === 'smart') {
                                // Calculate how many of MY units this enemy neighbors
                                let n = getNeighbors(r, c);
                                threat = n.friends; 
                            }
                            
                            attacks.push({r, c, score: val + (threat * 2)});
                        }
                    }
                }
            }

            if(attacks.length === 0) {
                log("AI PASS.");
                Game.passCount++;
                if(Game.passCount >= 2) endGame();
            } else {
                attacks.sort((a,b) => b.score - a.score);
                let best = attacks[0];
                log(`AI Neutralized target at [${best.r},${best.c}].`, "highlight");
                Game.grid[best.r][best.c].owner = 0;
                Game.grid[best.r][best.c].count = 0;
                Game.passCount = 0;
            }
        }

        function renderBoard() {
            for(let r=0; r<Game.rows; r++) {
                for(let c=0; c<Game.cols; c++) {
                    const el = document.getElementById(`cell-${r}-${c}`);
                    const d = Game.grid[r][c];
                    el.className = 'cell'; el.innerText = '';
                    if(d.owner === 1) { el.classList.add('p1'); el.innerText = d.count; }
                    if(d.owner === 2) { el.classList.add('p2'); el.innerText = d.count; }
                    
                    // Visual Aid: Highlight Valid Targets for Human
                    if(Game.phase === 'attack' && Game.turn === 1 && d.owner === 2) {
                         let power = 0;
                         // ... recalculate power for visualization ...
                         for(let dr=-1; dr<=1; dr++) {
                            for(let dc=-1; dc<=1; dc++) {
                                if(dr===0 && dc===0) continue;
                                let nr = r+dr, nc = c+dc;
                                if(nr>=0 && nr<Game.rows && nc>=0 && nc<Game.cols) {
                                    if(Game.grid[nr][nc].owner === 1) power += Game.grid[nr][nc].count;
                                }
                            }
                        }
                        if(power > d.count) el.classList.add('valid-target');
                    }
                }
            }
        }

        function endGame() {
            Game.phase = 'gameover';
            let p1 = parseInt(document.getElementById('p1-score').innerText);
            let p2 = parseInt(document.getElementById('p2-score').innerText);
            const wDisplay = document.getElementById('winner-display');
            
            if(p1 > p2) { wDisplay.innerText = "PLAYER 1 WINS"; wDisplay.style.color = "var(--p1-color)"; }
            else if(p2 > p1) { wDisplay.innerText = "PLAYER 2 WINS"; wDisplay.style.color = "var(--p2-color)"; }
            else { wDisplay.innerText = "DRAW MATCH"; wDisplay.style.color = "var(--accent)"; }
            
            document.getElementById('final-score').innerText = `P1: ${p1}  //  P2: ${p2}`;
            document.getElementById('game-over-modal').style.display = 'flex';
        }
    </script>
</body>
</html>
