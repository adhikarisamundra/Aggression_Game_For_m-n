<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>AGGRESSION: SINGULARITY</title>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;600;900&family=Share+Tech+Mono&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-deep: #00050a;
            --p1-hex: #00f3ff;
            --p1-dim: rgba(0, 243, 255, 0.1);
            --p2-hex: #ff003c;
            --p2-dim: rgba(255, 0, 60, 0.1);
            --accent-hex: #e0f2fe;
            --ui-glass: rgba(10, 20, 30, 0.9);
            --grid-line: #1a2332;
        }

        * { box-sizing: border-box; user-select: none; -webkit-tap-highlight-color: transparent; }

        body {
            font-family: 'Share Tech Mono', monospace;
            background-color: var(--bg-deep);
            color: var(--accent-hex);
            margin: 0; height: 100vh; overflow: hidden;
            display: flex; justify-content: center; align-items: center;
            background-image: radial-gradient(circle at 50% 50%, #111827 0%, #000 100%);
        }

        /* --- UI COMPONENTS --- */
        .panel {
            background: var(--ui-glass);
            border: 1px solid rgba(255,255,255,0.1);
            box-shadow: 0 0 40px rgba(0,0,0,0.8);
            backdrop-filter: blur(10px);
            border-radius: 4px;
        }

        .btn {
            background: rgba(255,255,255,0.05); color: var(--accent-hex);
            border: 1px solid rgba(255,255,255,0.2); padding: 12px 20px;
            font-family: 'Orbitron'; font-weight: bold; letter-spacing: 2px;
            cursor: pointer; transition: 0.2s; text-transform: uppercase;
        }
        .btn:hover { background: #fff; color: #000; box-shadow: 0 0 15px #fff; }
        .btn-danger { border-color: var(--p2-hex); color: var(--p2-hex); }
        .btn-danger:hover { background: var(--p2-hex); color: #000; box-shadow: 0 0 15px var(--p2-hex); }

        /* --- SETUP SCREEN --- */
        #setup-screen {
            position: absolute; z-index: 100; padding: 40px;
            display: flex; flex-direction: column; gap: 20px; width: 500px;
        }
        h1 {
            font-family: 'Orbitron'; font-size: 3.5rem; margin: 0; text-align: center;
            background: linear-gradient(180deg, #fff, #555);
            -webkit-background-clip: text; -webkit-text-fill-color: transparent;
            text-shadow: 0 0 20px rgba(255,255,255,0.2);
        }
        .config-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; }
        label { font-size: 0.7rem; color: #666; display: block; margin-bottom: 5px; }
        input, select {
            width: 100%; background: #000; border: 1px solid #333; color: #fff;
            padding: 10px; font-family: 'Share Tech Mono'; text-align: center;
            font-size: 1.1rem; outline: none;
        }
        input:focus, select:focus { border-color: var(--p1-hex); }

        /* --- GAME LAYOUT --- */
        #game-ui {
            display: none; width: 100%; height: 100%;
            grid-template-columns: 300px 1fr 300px;
            grid-template-rows: 60px 1fr 80px;
            gap: 20px; padding: 20px; z-index: 10;
        }

        /* TOP BAR */
        .top-bar { grid-column: 1 / -1; display: flex; justify-content: space-between; align-items: center; padding: 0 20px; }
        #phase-display {
            font-family: 'Orbitron'; font-size: 1.4rem; letter-spacing: 4px;
            color: #fff; text-shadow: 0 0 10px rgba(255,255,255,0.5);
            border: 1px solid rgba(255,255,255,0.2); padding: 5px 20px;
        }

        /* SIDEBARS */
        .sidebar {
            grid-row: 2 / 3; display: flex; flex-direction: column; gap: 20px;
            padding: 30px; transition: 0.3s; opacity: 0.5; border: 1px solid transparent;
        }
        /* ACTIVE TURN STYLES */
        .sidebar.active-p1 {
            opacity: 1; border-color: var(--p1-hex);
            box-shadow: 0 0 30px var(--p1-dim), inset 0 0 20px var(--p1-dim);
            transform: scale(1.02);
        }
        .sidebar.active-p2 {
            opacity: 1; border-color: var(--p2-hex);
            box-shadow: 0 0 30px var(--p2-dim), inset 0 0 20px var(--p2-dim);
            transform: scale(1.02);
        }

        .player-label { font-family: 'Orbitron'; font-size: 1.5rem; text-align: center; margin-bottom: 20px; }
        .stat-group { text-align: center; background: rgba(0,0,0,0.3); padding: 15px; border-radius: 4px; }
        .stat-val { font-family: 'Orbitron'; font-size: 3rem; font-weight: 900; line-height: 1; }
        .stat-name { font-size: 0.8rem; color: #666; letter-spacing: 2px; margin-top: 5px; }

        /* BOARD AREA */
        #board-area {
            grid-column: 2 / 3; grid-row: 2 / 3;
            display: flex; justify-content: center; align-items: center;
            position: relative;
        }
        #grid-frame {
            padding: 15px; background: rgba(0,0,0,0.8);
            border: 1px solid #333; box-shadow: 0 20px 50px #000;
        }
        #grid { display: grid; gap: 4px; }
        
        .cell {
            width: 60px; height: 60px; background: #0a0f18;
            border: 1px solid #222; display: flex; justify-content: center; align-items: center;
            font-family: 'Orbitron'; font-weight: bold; font-size: 1.5rem;
            cursor: pointer; transition: 0.1s; position: relative;
        }
        .cell:hover { border-color: #fff; z-index: 10; transform: scale(1.1); }
        
        /* PLAYER 1 UNITS */
        .cell.p1 {
            color: var(--p1-hex); border: 2px solid var(--p1-hex);
            background: rgba(0, 243, 255, 0.05);
            box-shadow: inset 0 0 15px rgba(0, 243, 255, 0.1);
        }
        /* PLAYER 2 UNITS */
        .cell.p2 {
            color: var(--p2-hex); border: 2px solid var(--p2-hex);
            background: rgba(255, 0, 60, 0.05);
            box-shadow: inset 0 0 15px rgba(255, 0, 60, 0.1);
        }
        /* LOCKED (Visual indicator that you can't place here) */
        .cell.locked { cursor: not-allowed; opacity: 0.8; }
        
        /* ATTACK PREVIEW */
        .cell.targetable { animation: flashRed 1s infinite; cursor: crosshair; }
        @keyframes flashRed { 0% {box-shadow: 0 0 0 var(--p2-hex);} 50% {box-shadow: 0 0 20px var(--p2-hex);} }

        /* BOTTOM BAR */
        #controls {
            grid-column: 2 / 3; grid-row: 3 / 4;
            display: flex; justify-content: center; align-items: center; gap: 20px;
        }
        
        #log-feed {
            grid-column: 1 / 2; grid-row: 3 / 4;
            font-size: 0.7rem; color: #666; overflow: hidden;
            display: flex; flex-direction: column-reverse;
            border-top: 2px solid #333; padding-top: 5px;
        }
        .log-entry { margin-bottom: 2px; }
        .log-high { color: var(--p1-hex); }
        .log-warn { color: var(--p2-hex); }

        /* MODALS */
        .modal-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.95); z-index: 200; display: none;
            justify-content: center; align-items: center;
        }
        .modal-box {
            background: #050a10; border: 1px solid var(--p1-hex); padding: 40px;
            text-align: center; max-width: 500px; width: 90%;
            box-shadow: 0 0 50px rgba(0, 243, 255, 0.1);
        }

        /* AI COMPUTING OVERLAY */
        #ai-overlay {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.9); border: 1px solid var(--p2-hex); color: var(--p2-hex);
            padding: 10px 20px; font-family: 'Orbitron'; z-index: 50; display: none;
            box-shadow: 0 0 20px var(--p2-hex); pointer-events: none;
        }

        @media (max-width: 900px) {
            #game-ui { display: flex; flex-direction: column; overflow-y: auto; }
            .sidebar { flex-direction: row; justify-content: space-around; padding: 10px; min-height: 80px; }
            #log-feed { display: none; }
        }
    </style>
</head>
<body>

    <div id="setup-screen" class="panel">
        <h1>AGGRESSION</h1>
        <div style="text-align:center; color:#666; margin-bottom:30px; letter-spacing:3px;">SINGULARITY ENGINE V9.0</div>
        
        <div class="config-grid">
            <div>
                <label>GRID ROWS (3-10)</label>
                <input type="number" id="rows" value="6" min="3" max="10">
            </div>
            <div>
                <label>GRID COLS (3-10)</label>
                <input type="number" id="cols" value="6" min="3" max="10">
            </div>
        </div>
        
        <div>
            <label>TOTAL TROOPS (PER PLAYER)</label>
            <input type="number" id="troops" value="36" min="1">
            <label style="margin-top:5px; color:#444;">RULE: NO STACKING ALLOWED</label>
        </div>

        <div>
            <label>OPPONENT INTELLIGENCE</label>
            <select id="ai-level">
                <option value="human">HUMAN (HOTSEAT)</option>
                <option value="weak">AI: DRONE (Random)</option>
                <option value="strategic">AI: TACTICIAN (Aggressive)</option>
                <option value="omega" selected>AI: SINGULARITY (Simulation)</option>
            </select>
        </div>

        <button class="btn" onclick="Game.init()">INITIALIZE</button>
        <button class="btn btn-danger" onclick="Data.open()">MISSION LOGS</button>
    </div>

    <div id="game-ui">
        
        <div class="top-bar panel">
            <div style="font-weight:bold; color:#fff;">AGGRESSION PROTOCOL</div>
            <div id="phase-display">PLACEMENT</div>
            <div onclick="location.reload()" style="cursor:pointer; color:#555;">[ABORT]</div>
        </div>

        <div class="sidebar panel" id="p1-bar">
            <div class="player-label" style="color:var(--p1-hex)">PLAYER 1</div>
            <div class="stat-group">
                <div class="stat-val" id="p1-res">0</div>
                <div class="stat-name">RESERVES</div>
            </div>
            <div class="stat-group">
                <div class="stat-val" id="p1-score">0</div>
                <div class="stat-name">SECTORS</div>
            </div>
        </div>

        <div id="board-area">
            <div id="ai-overlay">COMPUTING OPTIMAL VECTOR...</div>
            <div id="grid-frame">
                <div id="grid"></div>
            </div>
        </div>

        <div class="sidebar panel" id="p2-bar">
            <div class="player-label" style="color:var(--p2-hex)" id="p2-name">PLAYER 2</div>
            <div class="stat-group">
                <div class="stat-val" id="p2-res">0</div>
                <div class="stat-name">RESERVES</div>
            </div>
            <div class="stat-group">
                <div class="stat-val" id="p2-score">0</div>
                <div class="stat-name">SECTORS</div>
            </div>
        </div>

        <div id="log-feed"></div>

        <div id="controls" class="panel">
            <div id="place-ctrls" style="display:flex; align-items:center; gap:15px;">
                <span style="color:#888;">DEPLOYMENT SIZE:</span>
                <input type="number" id="deploy-amt" value="1" min="1" style="width:80px; background:#111; border:none;">
                <span style="font-size:0.7rem; color:#555;">(CLICK EMPTY TILE)</span>
            </div>
            <div id="attack-ctrls" style="display:none;">
                <span style="color:#888; margin-right:20px;">TARGET HOSTILE SECTOR</span>
                <button class="btn btn-danger" onclick="Game.passTurn()">PASS TURN</button>
            </div>
        </div>

    </div>

    <div id="data-modal" class="modal-overlay">
        <div class="modal-box">
            <h2 style="font-family:'Orbitron'; margin-bottom:20px;">MISSION ARCHIVES</h2>
            <div id="archive-list" style="height:200px; overflow-y:auto; border:1px solid #333; margin-bottom:20px; text-align:left; padding:10px;"></div>
            <div style="display:flex; gap:10px;">
                <button class="btn" style="flex:1" onclick="Data.export()">EXPORT DATA</button>
                <button class="btn" style="flex:1" onclick="Data.import()">IMPORT DATA</button>
            </div>
            <button class="btn btn-danger" style="width:100%; margin-top:10px;" onclick="Data.close()">CLOSE</button>
        </div>
    </div>

    <script>
        /* --- CORE ENGINE V9 --- */
        const Game = {
            rows: 0, cols: 0, grid: [],
            p1Res: 0, p2Res: 0,
            turn: 1, phase: 'setup', ai: null,
            firstMover: 0, hasMoved: false, passCount: 0,
            logs: [],

            init() {
                this.rows = +document.getElementById('rows').value;
                this.cols = +document.getElementById('cols').value;
                // Safety clamp
                this.rows = Math.max(3, Math.min(10, this.rows));
                this.cols = Math.max(3, Math.min(10, this.cols));
                
                const t = +document.getElementById('troops').value;
                this.p1Res = t; this.p2Res = t;
                
                const aiVal = document.getElementById('ai-level').value;
                this.ai = aiVal === 'human' ? null : aiVal;
                
                this.phase = 'placement';
                this.turn = Math.random() < 0.5 ? 1 : 2;
                this.firstMover = 0; this.hasMoved = false; this.passCount = 0;
                this.logs = [];

                this.grid = [];
                for(let r=0; r<this.rows; r++) {
                    let row = [];
                    for(let c=0; c<this.cols; c++) row.push({owner: 0, count: 0});
                    this.grid.push(row);
                }

                // UI Transition
                document.getElementById('setup-screen').style.display = 'none';
                document.getElementById('game-ui').style.display = 'grid';
                document.getElementById('p2-name').innerText = this.ai ? `AI: ${this.ai.toUpperCase()}` : "PLAYER 2";

                this.buildGrid();
                this.updateHUD();
                this.log("SYSTEM INITIALIZED");
                this.log(`P${this.turn} STARTS PLACEMENT`);
                this.checkAI();
            },

            buildGrid() {
                const el = document.getElementById('grid');
                el.style.gridTemplateColumns = `repeat(${this.cols}, 1fr)`;
                el.innerHTML = '';
                for(let r=0; r<this.rows; r++) for(let c=0; c<this.cols; c++) {
                    const d = document.createElement('div');
                    d.className = 'cell';
                    d.id = `c-${r}-${c}`;
                    d.onclick = () => this.handleInput(r, c);
                    el.appendChild(d);
                }
            },

            handleInput(r, c) {
                if(this.phase === 'over' || (this.ai && this.turn === 2)) return;
                
                if(this.phase === 'placement') {
                    const amt = +document.getElementById('deploy-amt').value || 1;
                    this.actionPlace(r, c, amt);
                } else {
                    this.actionAttack(r, c);
                }
            },

            /* --- LOGIC: PLACEMENT (NO STACKING) --- */
            actionPlace(r, c, amt) {
                const cell = this.grid[r][c];
                
                // RULE: NO STACKING. Must be empty.
                if(cell.owner !== 0) {
                    this.flashError(r, c);
                    this.log("ERROR: TILE OCCUPIED");
                    return;
                }

                const res = this.turn === 1 ? this.p1Res : this.p2Res;
                const actual = Math.min(amt, res);
                if(actual <= 0) return;

                cell.owner = this.turn;
                cell.count += actual;
                if(this.turn === 1) this.p1Res -= actual; else this.p2Res -= actual;

                if(!this.hasMoved) { this.firstMover = this.turn; this.hasMoved = true; }

                this.render(); this.updateHUD();
                
                // CHECK: Is board full? Or both out of troops?
                const boardFull = this.grid.every(row => row.every(c => c.owner !== 0));
                
                if((this.p1Res === 0 && this.p2Res === 0) || boardFull) {
                    this.startAttackPhase();
                } else {
                    // Turn switch logic
                    let next = this.turn === 1 ? 2 : 1;
                    let nextRes = next === 1 ? this.p1Res : this.p2Res;
                    
                    // If next player has no troops, keep current turn
                    if(nextRes > 0 && !boardFull) {
                        this.turn = next;
                    }
                }
                this.updateHUD(); this.checkAI();
            },

            startAttackPhase() {
                this.phase = 'attack';
                this.turn = this.firstMover;
                document.getElementById('phase-display').innerText = "COMBAT PHASE";
                document.getElementById('phase-display').style.borderColor = "var(--p2-hex)";
                document.getElementById('place-ctrls').style.display = 'none';
                document.getElementById('attack-ctrls').style.display = 'flex';
                this.log("PHASE CHANGE -> COMBAT");
            },

            /* --- LOGIC: ATTACK --- */
            actionAttack(r, c) {
                const cell = this.grid[r][c];
                if(cell.owner === 0 || cell.owner === this.turn) { return; } // Invalid

                let power = 0;
                for(let dr=-1; dr<=1; dr++) for(let dc=-1; dc<=1; dc++) {
                    if(dr===0&&dc===0)continue;
                    let nr=r+dr, nc=c+dc;
                    if(nr>=0 && nr<this.rows && nc>=0 && nc<this.cols && this.grid[nr][nc].owner === this.turn) {
                        power += this.grid[nr][nc].count;
                    }
                }

                if(power > cell.count) {
                    this.log(`P${this.turn} ELIMINATED [${r},${c}]`);
                    cell.owner = 0; cell.count = 0;
                    this.passCount = 0;
                } else {
                    this.log(`ATTACK FAILED [${r},${c}]`);
                    this.flashError(r, c);
                }
                
                this.render(); this.nextTurn();
            },

            passTurn() {
                this.passCount++;
                this.log(`P${this.turn} PASS`);
                if(this.passCount >= 2) this.endGame(); else this.nextTurn();
            },

            nextTurn() {
                this.turn = this.turn === 1 ? 2 : 1;
                this.updateHUD(); this.checkAI();
            },

            /* --- AI CONTROLLER --- */
            checkAI() {
                if(!this.ai || this.turn === 1 || this.phase === 'over') return;
                
                // Show thinking UI
                document.getElementById('ai-overlay').style.display = 'block';
                
                // Watchdog Timer: Force move if AI hangs
                const watchdog = setTimeout(() => {
                    console.warn("AI TIMEOUT - FORCING RANDOM MOVE");
                    this.executeAiMove(null); 
                }, 3000);

                // Small delay for UX
                setTimeout(() => {
                    let move = null;
                    if(this.phase === 'placement') {
                        // AI PLACEMENT
                        if(this.ai === 'omega') move = AI.getBestPlacement(this);
                        else if(this.ai === 'strategic') move = AI.getStrategicPlacement(this);
                        else move = AI.getRandomPlacement(this); // Weak

                        // Execute Place
                        clearTimeout(watchdog);
                        if(move) {
                            let amt = this.ai === 'weak' ? 1 : Math.floor(Math.random()*4)+2;
                            this.actionPlace(move.r, move.c, amt);
                        } else {
                            // No valid moves? (Board full)
                            this.startAttackPhase();
                            this.updateHUD(); this.checkAI();
                        }
                    } else {
                        // AI ATTACK
                        if(this.ai === 'omega') move = AI.getSimulationAttack(this);
                        else if(this.ai === 'strategic') move = AI.getBestAttack(this);
                        else move = AI.getRandomAttack(this);

                        clearTimeout(watchdog);
                        if(move) {
                            this.actionAttack(move.r, move.c);
                        } else {
                            this.passTurn();
                        }
                    }
                    document.getElementById('ai-overlay').style.display = 'none';
                }, 800);
            },

            render() {
                for(let r=0; r<this.rows; r++) for(let c=0; c<this.cols; c++) {
                    const d = this.grid[r][c];
                    const el = document.getElementById(`c-${r}-${c}`);
                    el.className = 'cell'; el.innerText = '';
                    if(d.owner === 1) { el.classList.add('p1'); el.innerText = d.count; }
                    if(d.owner === 2) { el.classList.add('p2'); el.innerText = d.count; }
                    
                    // Locked visual for placement
                    if(this.phase === 'placement' && d.owner !== 0) el.classList.add('locked');

                    // Attack preview
                    if(this.phase === 'attack' && this.turn === 1 && d.owner === 2) {
                        // Calc power for viz
                        let p = 0;
                        for(let dr=-1; dr<=1; dr++) for(let dc=-1; dc<=1; dc++) {
                            if(dr===0&&dc===0)continue;
                            let nr=r+dr, nc=c+dc;
                            if(nr>=0 && nr<this.rows && nc>=0 && nc<this.cols && this.grid[nr][nc].owner === 1) {
                                p += this.grid[nr][nc].count;
                            }
                        }
                        if(p > d.count) el.classList.add('targetable');
                    }
                }
            },

            updateHUD() {
                document.getElementById('p1-res').innerText = this.p1Res;
                document.getElementById('p2-res').innerText = this.p2Res;
                
                const p1Bar = document.getElementById('p1-bar');
                const p2Bar = document.getElementById('p2-bar');
                p1Bar.classList.remove('active-p1', 'active-p2');
                p2Bar.classList.remove('active-p1', 'active-p2');

                if(this.turn === 1) p1Bar.classList.add('active-p1');
                if(this.turn === 2) p2Bar.classList.add('active-p2');

                let s1=0, s2=0;
                this.grid.forEach(r => r.forEach(c => {
                    if(c.owner===1) s1++; if(c.owner===2) s2++;
                }));
                document.getElementById('p1-score').innerText = s1;
                document.getElementById('p2-score').innerText = s2;
            },

            log(msg) {
                const el = document.getElementById('log-feed');
                const div = document.createElement('div');
                div.className = 'log-entry';
                if(msg.includes('P1')) div.classList.add('log-high');
                if(msg.includes('AI') || msg.includes('P2')) div.classList.add('log-warn');
                div.innerText = `>> ${msg}`;
                el.prepend(div);
                this.logs.push(`[${new Date().toLocaleTimeString()}] ${msg}`);
            },

            flashError(r, c) {
                const el = document.getElementById(`c-${r}-${c}`);
                el.style.backgroundColor = '#fff';
                setTimeout(() => el.style.backgroundColor = '', 100);
            },

            endGame() {
                this.phase = 'over';
                let s1 = +document.getElementById('p1-score').innerText;
                let s2 = +document.getElementById('p2-score').innerText;
                let w = s1>s2 ? "PLAYER 1" : (s2>s1 ? "AI / PLAYER 2" : "DRAW");
                
                Data.save(w, `${s1}-${s2}`, this.logs);
                setTimeout(() => alert(`MISSION END.\nVICTOR: ${w}\n\nDATA ARCHIVED.`), 500);
            }
        };

        /* --- ADVANCED AI ENGINE --- */
        const AI = {
            // 1. Heatmap Placement (Finds empty tile with most influence)
            getBestPlacement(g) {
                let moves = [];
                for(let r=0; r<g.rows; r++) for(let c=0; c<g.cols; c++) {
                    if(g.grid[r][c].owner === 0) { // MUST BE EMPTY
                        let score = 0;
                        // Center bias
                        let dist = Math.abs(r - g.rows/2) + Math.abs(c - g.cols/2);
                        score -= dist;
                        
                        // Neighbor analysis
                        for(let dr=-1; dr<=1; dr++) for(let dc=-1; dc<=1; dc++) {
                            if(dr===0&&dc===0)continue;
                            let nr=r+dr, nc=c+dc;
                            if(nr>=0 && nr<g.rows && nc>=0 && nc<g.cols) {
                                if(g.grid[nr][nc].owner === 2) score += 5; // Support friend
                                if(g.grid[nr][nc].owner === 1) score -= 2; // Avoid direct contact early
                            }
                        }
                        moves.push({r,c,score});
                    }
                }
                moves.sort((a,b) => b.score - a.score);
                return moves.length ? moves[0] : null;
            },

            getStrategicPlacement(g) {
                // Simple clustering
                let moves = [];
                for(let r=0; r<g.rows; r++) for(let c=0; c<g.cols; c++) {
                    if(g.grid[r][c].owner === 0) {
                        let friends = 0;
                        for(let dr=-1; dr<=1; dr++) for(let dc=-1; dc<=1; dc++) {
                            if(dr===0&&dc===0)continue;
                            let nr=r+dr, nc=c+dc;
                            if(nr>=0&&nr<g.rows&&nc>=0&&nc<g.cols && g.grid[nr][nc].owner===2) friends++;
                        }
                        moves.push({r,c,score:friends});
                    }
                }
                moves.sort((a,b) => b.score - a.score);
                return moves.length ? moves[0] : this.getRandomPlacement(g);
            },

            getRandomPlacement(g) {
                let empties = [];
                for(let r=0; r<g.rows; r++) for(let c=0; c<g.cols; c++) {
                    if(g.grid[r][c].owner === 0) empties.push({r,c});
                }
                return empties.length ? empties[Math.floor(Math.random()*empties.length)] : null;
            },

            // 2. Simulation Attack (Monte Carlo Lite)
            getSimulationAttack(g) {
                let attacks = this.getAllAttacks(g);
                if(attacks.length === 0) return null;
                
                // Score based on value + safety
                attacks.forEach(atk => {
                    atk.score = atk.val * 10; // Base value
                    // Simulate: If I kill this, how exposed am I? (Simplified)
                    let exposure = 0;
                    // Check neighbors of the target (enemies of the target, aka friends of AI)
                    // If AI kills target, does it open a hole?
                    atk.score -= Math.random() * 5; // Add noise
                });
                
                attacks.sort((a,b) => b.score - a.score);
                return attacks[0];
            },

            getBestAttack(g) {
                let attacks = this.getAllAttacks(g);
                if(attacks.length === 0) return null;
                attacks.sort((a,b) => b.val - a.val); // Greedy
                return attacks[0];
            },

            getRandomAttack(g) {
                let attacks = this.getAllAttacks(g);
                return attacks.length ? attacks[Math.floor(Math.random()*attacks.length)] : null;
            },

            getAllAttacks(g) {
                let moves = [];
                for(let r=0; r<g.rows; r++) for(let c=0; c<g.cols; c++) {
                    if(g.grid[r][c].owner === 1) { // Enemy
                        let p = 0;
                        for(let dr=-1; dr<=1; dr++) for(let dc=-1; dc<=1; dc++) {
                            if(dr===0&&dc===0)continue;
                            let nr=r+dr, nc=c+dc;
                            if(nr>=0 && nr<g.rows && nc>=0 && nc<g.cols && g.grid[nr][nc].owner === 2) {
                                p += g.grid[nr][nc].count;
                            }
                        }
                        if(p > g.grid[r][c].count) {
                            moves.push({r, c, val: g.grid[r][c].count});
                        }
                    }
                }
                return moves;
            }
        };

        /* --- DATA MANAGEMENT (Archives) --- */
        const Data = {
            key: 'aggression_save_v2',
            get() { return JSON.parse(localStorage.getItem(this.key) || "[]"); },
            save(winner, score, logs) {
                const db = this.get();
                db.unshift({ id: Date.now().toString(36), date: new Date().toLocaleDateString(), winner, score, logs });
                localStorage.setItem(this.key, JSON.stringify(db));
            },
            open() {
                document.getElementById('data-modal').style.display = 'flex';
                const el = document.getElementById('archive-list');
                const db = this.get();
                el.innerHTML = db.length ? '' : 'NO DATA FOUND';
                db.forEach(g => {
                    el.innerHTML += `<div style="border-bottom:1px solid #333; padding:5px; font-size:0.8rem;">
                        <span style="color:#888">${g.date}</span> | 
                        <strong style="color:${g.winner.includes('1')?'#0ff':'#f05'}">${g.winner}</strong> 
                        (${g.score})
                    </div>`;
                });
            },
            close() { document.getElementById('data-modal').style.display = 'none'; },
            export() {
                const str = btoa(localStorage.getItem(this.key) || "[]");
                prompt("COPY THIS CODE:", str);
            },
            import() {
                const str = prompt("PASTE CODE:");
                if(str) {
                    try {
                        localStorage.setItem(this.key, atob(str));
                        alert("SYNC SUCCESSFUL");
                        this.open();
                    } catch(e) { alert("INVALID CODE"); }
                }
            }
        };
    </script>
</body>
</html>
